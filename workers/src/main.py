"""
FinLab MCP Server for Cloudflare Workers

Auto-generated by build.py - DO NOT EDIT MANUALLY
Documentation is embedded from finlab-plugin/skills/finlab/*.md
"""

from mcp.server.fastmcp import FastMCP

mcp = FastMCP("finlab-docs")

# Embedded documentation (auto-generated from finlab-plugin/skills/finlab/*.md)
DOCS: dict[str, str] = {
  "backtesting-reference": "# Backtesting Reference\n\n## Overview\n\nThe FinLab backtesting framework allows you to simulate trading strategies using historical data. The `backtest.sim()` function is the core tool for evaluating strategy performance, supporting various parameters for rebalancing, transaction costs, stop-loss/take-profit, and more.\n\n---\n\n## backtest.sim\n\nSimulate the equity curve of a stock portfolio based on its position history and market data. This function supports various parameters for rebalancing frequency, transaction costs, stop loss/take profit, and notification via Line.\n\n**Import:**\n```python\nfrom finlab import backtest\n```\n\n**Signature:**\n```python\nsim(\n    position: Union[pd.DataFrame, pd.Series],\n    resample: Union[str, None] = None,\n    resample_offset: Union[str, None] = None,\n    trade_at_price: Union[str, pd.DataFrame] = 'close',\n    position_limit: float = 1,\n    fee_ratio: float = 1.425/1000,\n    tax_ratio: float = 3/1000,\n    name: str = 'Êú™ÂëΩÂêç',\n    stop_loss: Union[float, None] = None,\n    take_profit: Union[float, None] = None,\n    trail_stop: Union[float, None] = None,\n    touched_exit: bool = False,\n    retain_cost_when_rebalance: bool = False,\n    stop_trading_next_period: bool = True,\n    live_performance_start: Union[str, None] = None,\n    mae_mfe_window: int = 0,\n    mae_mfe_window_step: int = 1,\n    market: Union[None, Market] = None,\n    upload: bool = True,\n    fast_mode: bool = False,\n    notification_enable: bool = False,\n    line_access_token: str = ''\n) -> report.Report\n```\n\n### Parameters\n\n#### position\n- **Type:** `Union[pd.DataFrame, pd.Series]`\n- **Required:** Yes\n- **Description:** A pandas DataFrame or Series representing the buy/sell signals (True indicates holding, False indicates no position). For short positions, negative values can be used. The index should be a DatetimeIndex, and the columns should represent stock IDs.\n\n#### resample\n- **Type:** `Union[str, None]`\n- **Default:** `None`\n- **Description:** Trading frequency or rebalancing dates specification. It can be a string (e.g., 'D', 'W', 'M'), a DataFrame, Series, or None. When None, rebalancing only occurs on changes in the position.\n\n#### resample_offset\n- **Type:** `Union[str, None]`\n- **Default:** `None`\n- **Description:** An optional time offset (e.g., '1D', '1H') applied to rebalance dates.\n\n#### trade_at_price\n- **Type:** `Union[str, pd.DataFrame]`\n- **Default:** `'close'`\n- **Description:** Specifies which market price to use in the simulation. Options include 'close', 'open', 'open_close_avg', 'high_low_avg', or a custom DataFrame with price data.\n\n#### position_limit\n- **Type:** `float`\n- **Default:** `1`\n- **Description:** Limit for the maximum weight assigned to any single asset (e.g., 0.2 for 20%).\n\n#### fee_ratio\n- **Type:** `float`\n- **Default:** `1.425/1000`\n- **Description:** Commission fee ratio applied during trades.\n\n#### tax_ratio\n- **Type:** `float`\n- **Default:** `3/1000`\n- **Description:** Transaction tax ratio applied when selling stocks.\n\n#### name\n- **Type:** `str`\n- **Default:** `'Êú™ÂëΩÂêç'`\n- **Description:** Name for the strategy (for reporting purposes).\n\n#### stop_loss\n- **Type:** `Union[float, None]`\n- **Default:** `None`\n- **Description:** Stop loss percentage threshold. If set to None, stop loss is disabled.\n\n#### take_profit\n- **Type:** `Union[float, None]`\n- **Default:** `None`\n- **Description:** Take profit percentage threshold. If set to None, take profit is disabled.\n\n#### trail_stop\n- **Type:** `Union[float, None]`\n- **Default:** `None`\n- **Description:** Trailing stop threshold. If set to None, trailing stop is disabled.\n\n#### touched_exit\n- **Type:** `bool`\n- **Default:** `False`\n- **Description:** Flag to enable price touch exit logic. Use with caution as it may affect candle details.\n\n#### retain_cost_when_rebalance\n- **Type:** `bool`\n- **Default:** `False`\n- **Description:** Whether to carry forward the original cost basis when rebalancing positions.\n\n#### stop_trading_next_period\n- **Type:** `bool`\n- **Default:** `True`\n- **Description:** If a stop loss/take profit event occurs, trading is suspended for the next period.\n\n#### mae_mfe_window\n- **Type:** `int`\n- **Default:** `0`\n- **Description:** Window length for calculating maximum adverse excursion (MAE) and maximum favorable excursion (MFE).\n\n#### mae_mfe_window_step\n- **Type:** `int`\n- **Default:** `1`\n- **Description:** Step interval for the MAE/MFE analysis.\n\n#### upload\n- **Type:** `bool`\n- **Default:** `True`\n- **Description:** Determines whether to upload the strategy performance report after simulation.\n\n### Returns\n\nAn instance of `Report` containing performance metrics, trades, and additional analyses.\n\n---\n\n## Report Class Reference\n\nThe `sim()` function returns a `Report` object with multiple APIs for accessing performance metrics.\n\n### Method 1: `report.metrics` (Recommended for single metrics)\n\nAccess individual metrics via the `Metrics` instance:\n\n```python\nreport = sim(position, resample=\"M\", upload=False)\n\n# Individual metric methods\nprint(f\"Annual Return: {report.metrics.annual_return():.2%}\")\nprint(f\"Sharpe Ratio: {report.metrics.sharpe_ratio():.2f}\")\nprint(f\"Max Drawdown: {report.metrics.max_drawdown():.2%}\")\n```\n\n### Method 2: `report.get_stats()` (Returns dictionary)\n\nReturns a flat dictionary with all stats. Useful for batch access:\n\n```python\nstats = report.get_stats()\n\n# Dictionary keys (note: different names than metrics methods!)\nprint(f\"Annual Return: {stats['cagr']:.2%}\")\nprint(f\"Sharpe Ratio: {stats['monthly_sharpe']:.2f}\")\nprint(f\"Max Drawdown: {stats['max_drawdown']:.2%}\")\nprint(f\"Win Ratio: {stats['win_ratio']:.2%}\")\nprint(f\"Total Return: {stats['total_return']:.2%}\")\n```\n\n**Available keys in `get_stats()`:**\n- `cagr` - Compound Annual Growth Rate\n- `daily_sharpe` - Daily Sharpe ratio\n- `monthly_sharpe` - Monthly Sharpe ratio\n- `max_drawdown` - Maximum drawdown (negative value)\n- `win_ratio` - Win rate of trades\n- `total_return` - Total cumulative return\n- `start` - Backtest start date (string)\n- `end` - Backtest end date (string)\n- `return_table` - Dict of monthly returns by year\n\n### Method 3: `report.get_metrics()` (Structured nested dictionary)\n\nReturns a nested dictionary organized by category:\n\n```python\nmetrics = report.get_metrics()\n\n# Structured access\nprint(metrics['profitability']['annualReturn'])\nprint(metrics['ratio']['sharpeRatio'])\nprint(metrics['risk']['maxDrawdown'])\n```\n\n**Categories:**\n- `backtest` - startDate, endDate, feeRatio, taxRatio, market, freq\n- `profitability` - annualReturn, alpha, beta, avgNStock, maxNStock\n- `risk` - maxDrawdown, avgDrawdown, avgDrawdownDays, valueAtRisk\n- `ratio` - sharpeRatio, sortinoRatio, calmarRatio, volatility\n- `winrate` - winRate, m12WinRate, expectancy, mae, mfe\n- `liquidity` - capacity, disposalStockRatio, warningStockRatio\n\n### Other Useful Methods\n\n```python\n# Display interactive report\nreport.display()\n\n# Get trade details\ntrades_df = report.get_trades()\n\n# Save to file\nreport.to_html(\"report.html\")\nreport.to_pickle(\"report.pkl\")\n\n# Load from file\nloaded_report = Report.from_pickle(\"report.pkl\")\n\n# Run specific analysis\nreport.run_analysis(\"Drawdown\")\nreport.run_analysis(\"MaeMfe\")\n```\n\n### Key Attribute Mappings\n\n| Desired Metric | `report.metrics.X()` | `report.get_stats()['X']` |\n|----------------|----------------------|---------------------------|\n| Annual Return | `annual_return()` | `'cagr'` |\n| Sharpe Ratio | `sharpe_ratio()` | `'monthly_sharpe'` |\n| Max Drawdown | `max_drawdown()` | `'max_drawdown'` |\n| Win Rate | `win_rate()` | `'win_ratio'` |\n| Total Return | - | `'total_return'` |\n\n---\n\n## Example Usage\n\n### Basic Example\n\n```python\nimport pandas as pd\nfrom finlab import backtest\n\n# Example position DataFrame with dates as index\nposition = pd.DataFrame({\n    '2330': [0, 1, 1],\n    '1101': [0.2, 0, 0],\n    '2454': [0.4, 0, 0]\n}, index=pd.to_datetime(['2021-12-31', '2022-03-31', '2022-06-30']))\n\nreport = backtest.sim(position)\nprint(report)\n```\n\n### Advanced Example with Stop Loss and Take Profit\n\n```python\nfrom finlab import data, backtest\n\nclose = data.get('price:Êî∂Áõ§ÂÉπ')\npb = data.get('price_earning_ratio:ËÇ°ÂÉπÊ∑®ÂÄºÊØî')\n\n# Define entry and exit conditions\nentries = close > close.average(20)\nexits = close < close.average(60)\n\n# Create position with ranking\nposition = entries.hold_until(exits, nstocks_limit=10, rank=-pb)\n\n# Backtest with stop loss and take profit\nreport = backtest.sim(\n    position,\n    resample='M',\n    stop_loss=0.1,      # 10% stop loss\n    take_profit=0.2,    # 20% take profit\n    name='MA Strategy with SL/TP'\n)\n\n# Display metrics\nprint(report.get_metrics())\n```\n\n---\n\n## Strategy Development Workflow\n\n### Step 1: Fetching Data\n\nGather the necessary data using `data.get()`, including historical prices, volume, and any relevant indicators.\n\n**Important Notes:**\n- Use `with data.universe(...)` ONLY to scope `data.get(...)` calls; do NOT wrap position DataFrame operations\n- When specifying category/exclude_category, use industry names only (no numeric codes like '28')\n\n**Example:**\n```python\nfrom finlab import data\n\nclose = data.get('price:Êî∂Áõ§ÂÉπ')\nvolume = data.get('price:Êàê‰∫§ËÇ°Êï∏')\nrevenue = data.get('monthly_revenue:Áï∂ÊúàÁáüÊî∂')\n```\n\n---\n\n### Step 2: Factor Creation\n\nCreate factors or indicators that will be used in your strategy.\n\n**Available Methods:**\n- `average`, `rolling(n).mean`, `rolling(n).std`, `rolling(n).max`, `rolling(n).min`\n- `is_largest`, `is_smallest`\n- `sustain`, `rise`, `fall`\n- `industry_rank`, `quantile_row`\n- Arithmetic operators: `+`, `-`, `*`, `/`\n- Comparison operators: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical operators: `&`, `|`, `~`\n\n**Important Notes:**\n- Do not use `==` for floating point comparisons. Use `np.isclose()` instead\n- Be cautious with `&` and `|` operators; ensure proper parentheses to avoid precedence issues\n- Prevent using reindex to align FinlabDataFrame as it already has aligned indices and columns\n- Do not use for loops to iterate over rows or columns. Use vectorized operations instead\n\n**Example:**\n```python\n# Calculate moving averages\nsma20 = close.average(20)\nsma60 = close.average(60)\n\n# Revenue growth\nrev_growth = revenue.pct_change(12)\n\n# Combine multiple conditions\nstrong_momentum = (close > sma20) & (close > sma60)\n```\n\n---\n\n### Step 3: Construct Position\n\nDefine the DataFrame structure for your trading positions. The index should be a DatetimeIndex, and the columns should represent stock IDs. Use boolean values to indicate whether to hold or not, or numeric values for position sizes.\n\n**Important Notes:**\n- If user does not mention the sell condition, you can just use `position = a & b & c`\n- Without sell condition, the position will be held until the end of the resample period, which is recommended, since we can set stop loss or take profit in the sim function\n- If user mentions the sell condition, it is recommended to use `position = buy.hold_until(sell)` where buy is `(a & b & c)` and sell is `(a | b | c)`\n- Use `&` and `|` to combine multiple conditions, and use parentheses to ensure correct precedence\n- DO NOT use for loop to iterate over rows or columns. FinlabDataFrame already has aligned indices and columns for you\n\n**Example:**\n```python\n# Simple position without explicit sell condition\nposition = (close > sma20) & (rev_growth > 0.1)\n\n# Position with entry and exit signals\nbuy = (close > sma20) & (volume > volume.average(20))\nsell = (close < sma60) | (rev_growth < 0)\nposition = buy.hold_until(sell, nstocks_limit=10)\n```\n\n---\n\n### Step 4: Backtest the Strategy\n\nTest your strategy's performance and make adjustments as needed.\n\n**Associated Methods:**\n- `backtest.sim`\n- `report.display`\n- `report.get_metrics`\n\n**Important Notes:**\n- Use the `sim` function to simulate performance based on your position DataFrame\n- If monthly revenue is used (as variable `rev`), please set `resample` to `rev.index`\n- If user not mention, please set `resample` to 'ME' or 'Q' to avoid overtrading\n- Use `print(report.get_metrics())` to extract performance metrics\n- If scoping tradable universe at simulation time, you may wrap the backtest call with `with data.universe(...)` ‚Äî but NEVER wrap factor/position calculations inside that context\n\n**Example:**\n```python\nfrom finlab import backtest\n\n# Simple backtest\nreport = backtest.sim(position, resample='M')\n\n# Backtest with universe filtering\nwith data.universe(market='TSE_OTC', exclude_category='ÈáëËûç'):\n    report = backtest.sim(position, resample='Q')\n\n# Display metrics\nprint(report.get_metrics())\nreport.display()\n```\n\n---\n\n## Related References\n\n- [FinlabDataFrame Reference](dataframe-reference.md) - Learn about enhanced DataFrame methods\n- [Data Reference](data-reference.md) - Explore available data sources\n- [Factor Examples](factor-examples.md) - See complete strategy examples\n- [Factor Analysis Reference](factor-analysis-reference.md) - Analyze factor performance\n",
  "best-practices": "# FinLab Best Practices and Anti-Patterns\n\nThis document contains critical coding patterns, anti-patterns, and best practices for developing FinLab strategies. **Following these guidelines prevents common errors, lookahead bias, and data pollution.**\n\n## Table of Contents\n\n1. [Code Patterns (DO THIS)](#code-patterns-do-this)\n2. [Anti-Patterns (DON'T DO THIS)](#anti-patterns-dont-do-this)\n3. [Preventing Future Data Pollution](#preventing-future-data-pollution)\n4. [Stock Selection Patterns](#stock-selection-patterns)\n5. [Backtesting Patterns](#backtesting-patterns)\n6. [Error Handling](#error-handling)\n\n---\n\n## Code Patterns (DO THIS)\n\n### ‚úÖ Combine Conditions with Logical Operators\n\n**DO:** Use `&`, `|`, `~` to combine conditions into a single position DataFrame.\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\nfactor1 = data.get(\"price:Êî∂Áõ§ÂÉπ\")\nfactor2 = data.get(\"monthly_revenue:Áï∂ÊúàÁáüÊî∂\")\nfactor3 = data.get(\"price_earning_ratio:Êú¨ÁõäÊØî\")\n\ncond1 = factor1.rank(axis=1, pct=True) > 0.5\ncond2 = factor2.rank(axis=1, pct=True) > 0.5\n\ncond_intersection = cond1 & cond2\nposition = factor3[cond_intersection].is_smallest(5)\n\nreport = sim(position, resample=\"M\")\n```\n\n**DON'T:** Create separate functions to generate positions (adds unnecessary complexity).\n\n### ‚úÖ Use `is_smallest()` or `is_largest()` for Stock Selection\n\n**DO:** Limit to top N < 50 stocks using these methods.\n\n```python\n# Select top 10 stocks by lowest P/E\npe = data.get(\"price_earning_ratio:Êú¨ÁõäÊØî\")\nposition = pe.is_smallest(10)\n\n# Select top 15 stocks by highest momentum, where condition is met\nclose = data.get(\"price:Êî∂Áõ§ÂÉπ\")\nmomentum = close / close.shift(20) - 1\ncondition = close > close.average(60)\nposition = momentum[condition].is_largest(15)\n```\n\n**Note:** The DataFrame used with `is_smallest()`/`is_largest()` must have **float dtype**, not bool. If you have a boolean condition, apply it as a filter first.\n\n### ‚úÖ Use Correct Technical Indicator Syntax\n\n**DO:** Call `data.indicator()` without passing OHLCV data.\n\n```python\n# Correct - no OHLCV parameters\nrsi = data.indicator(\"RSI\", timeperiod=14)\n\n# Correct - multiple return values\nmacd, macd_signal, macd_hist = data.indicator(\n    \"MACD\",\n    fastperiod=12,\n    slowperiod=26,\n    signalperiod=9\n)\n\n# Correct - Bollinger Bands\nupperband, middleband, lowerband = data.indicator(\n    \"BBANDS\",\n    timeperiod=20,\n    nbdevup=2.0,\n    nbdevdn=2.0,\n    matype=0\n)\n```\n\n**DON'T:** Pass close price or OHLCV data to indicators.\n\n```python\n# ‚ùå WRONG - don't pass close\nrsi = data.indicator(\"RSI\", close, timeperiod=14)  # ERROR\n```\n\n### ‚úÖ Use `df.shift(1)` for Previous Values\n\n**DO:** Use `.shift()` to access historical data.\n\n```python\n# Correct - get previous day's close\nprev_close = close.shift(1)\n\n# Correct - detect crossover\nsma20 = close.average(20)\nsma60 = close.average(60)\ngolden_cross = (sma20 > sma60) & (sma20.shift() < sma60.shift())\n```\n\n**DON'T:** Use `.iloc[-2]` or similar indexing (can cause lookahead bias).\n\n```python\n# ‚ùå WRONG\nprev_close = close.iloc[-2]  # DON'T USE THIS\n```\n\n### ‚úÖ Use `data.universe()` for Filtering\n\n**DO:** Use context manager or `set_universe()` to filter stocks by market/category.\n\n```python\nfrom finlab import data\n\n# Method 1: Context manager (temporary scope)\nwith data.universe(market='TSE_OTC', category=['Ê∞¥Ê≥•Â∑•Ê•≠']):\n    price = data.get('price:Êî∂Áõ§ÂÉπ')\n\n# Method 2: Set globally\ndata.set_universe(market='TSE_OTC', category='ÂçäÂ∞éÈ´î', exclude_category='ÈáëËûç')\nprice = data.get('price:Êî∂Áõ§ÂÉπ')\n```\n\nSee [data-reference.md](data-reference.md) for complete `data.universe()` usage.\n\n### ‚úÖ Assign `resample` to Prevent Overtrading\n\n**DO:** Always specify `resample` parameter in `sim()`.\n\n```python\n# Monthly rebalancing\nsim(position, resample=\"M\")\n\n# Weekly rebalancing\nsim(position, resample=\"W\")\n\n# Use monthly revenue index\nrev = data.get('monthly_revenue:Áï∂ÊúàÁáüÊî∂')\nsim(position, resample=rev.index)\n```\n\n**DON'T:** Omit `resample` (defaults to daily, causes excessive trading).\n\n---\n\n## Anti-Patterns (DON'T DO THIS)\n\n### ‚ùå Don't Use `==` for Float Comparisons\n\n**Reason:** Floating point precision issues.\n\n```python\n# ‚ùå BAD\ncondition = (close == 100.0)\n\n# ‚úÖ GOOD - use inequalities or np.isclose()\nimport numpy as np\ncondition = np.isclose(close, 100.0)\n# Or better:\ncondition = (close > 99.9) & (close < 100.1)\n```\n\n### ‚ùå Don't Use `reindex()` on FinLabDataFrame\n\n**Reason:** FinLabDataFrame already automatically aligns indices/columns.\n\n```python\n# ‚ùå BAD - unnecessary reindexing\ndf1 = data.get(\"price:Êî∂Áõ§ÂÉπ\")\ndf2 = data.get(\"monthly_revenue:Áï∂ÊúàÁáüÊî∂\")\ndf2_reindexed = df2.reindex(df1.index, method='ffill')  # DON'T DO THIS\n\n# ‚úÖ GOOD - automatic alignment\nposition = df1 > df1.average(60) & (df2 > df2.shift(1))\n```\n\n**Exception:** Only use `reindex()` for position DataFrame when changing to a specific resampling schedule:\n\n```python\n# ‚úÖ Allowed - reindex position to monthly revenue dates\nrev = data.get('monthly_revenue:Áï∂ÊúàÁáüÊî∂')\nposition_resampled = position.reindex(rev.index_str_to_date().index, method=\"ffill\")\n```\n\n### ‚ùå Don't Use For Loops\n\n**Reason:** FinLabDataFrame methods are vectorized and much faster.\n\n```python\n# ‚ùå BAD - iterating over rows\nfor date in close.index:\n    for stock in close.columns:\n        if close.loc[date, stock] > sma60.loc[date, stock]:\n            position.loc[date, stock] = True\n\n# ‚úÖ GOOD - vectorized operations\nposition = close > sma60\n```\n\n### ‚ùå Don't Filter Ê≥®ÊÑèËÇ°/ËôïÁΩÆËÇ°/ÂÖ®È°ç‰∫§Ââ≤ËÇ° Unless Asked\n\n**Reason:** These filters remove many stocks and should only be applied when explicitly requested.\n\n```python\n# ‚ùå DON'T do this by default\nis_regular = (\n    data.get(\"etl:noticed_stock_filter\") &\n    data.get(\"etl:disposal_stock_filter\") &\n    data.get(\"etl:full_cash_delivery_stock_filter\")\n)\nposition = position & is_regular\n\n# ‚úÖ Only do this if user specifically asks to remove these stocks\n```\n\n### ‚ùå Don't Pass OHLCV to Technical Indicators\n\n**Reason:** `data.indicator()` automatically uses correct price data.\n\n```python\n# ‚ùå WRONG\nclose = data.get(\"price:Êî∂Áõ§ÂÉπ\")\nrsi = data.indicator(\"RSI\", close, timeperiod=14)  # ERROR\n\n# ‚úÖ CORRECT\nrsi = data.indicator(\"RSI\", timeperiod=14)  # Automatically uses close\n```\n\n### ‚ùå Don't Use Boolean Indexing with Mismatched Indices\n\n**Reason:** When extracting `.iloc[-1]` from DataFrames with different columns, the resulting Series have different indices. Boolean indexing then fails with `IndexingError`.\n\n```python\n# ‚ùå BAD - indices may not match\nselected = latest_pe[latest_combined]  # IndexingError\n\n# ‚úÖ GOOD - align indices first\ncommon = latest_combined.index.intersection(latest_pe.index)\nselected = latest_pe.loc[common][latest_combined.loc[common]]\n```\n\n---\n\n## Preventing Future Data Pollution\n\n**Critical:** Future data pollution (lookahead bias) occurs when you use information that wouldn't have been available at the time of decision-making. This silently corrupts backtests and makes them unrealistic.\n\n### ‚úÖ Leave `df.index` As-Is\n\n**DO:** Keep index intact, even if it contains strings like \"2025Q1\".\n\n```python\n# ‚úÖ GOOD - leave index as-is\nrevenue = data.get(\"monthly_revenue:Áï∂ÊúàÁáüÊî∂\")\n# Index may contain strings like \"2022-01\", \"2022-02\", etc.\n# FinLabDataFrame aligns by shape in binary operations\nposition = revenue > revenue.shift(1)\n```\n\n**DON'T:** Manually assign to `df.index`.\n\n```python\n# ‚ùå FORBIDDEN - can corrupt shared data\ndf.index = new_index  # NEVER DO THIS\n```\n\n### ‚úÖ Use Only Approved Resampling Method\n\n**DO:** Use exactly this pattern for resampling (datetime index required, use `.last()` only).\n\n```python\n# ‚úÖ CORRECT resampling pattern\ndf = df.index_str_to_date().resample('M').last()\n```\n\n**DON'T:** Use other aggregation methods like `.mean()`, `.first()`, `.ffill()`.\n\n```python\n# ‚ùå WRONG\ndf = df.resample('M').mean()  # Can cause lookahead\ndf = df.resample('M').ffill()  # Can cause lookahead\n```\n\n### ‚úÖ Use Only Approved Reindexing Method\n\n**DO:** Use exactly `method='ffill'` for reindexing.\n\n```python\n# ‚úÖ CORRECT\ndf = df.reindex(target_index, method='ffill')\n```\n\n**DON'T:** Use other methods like `'bfill'` or `None`.\n\n```python\n# ‚ùå WRONG\ndf = df.reindex(target_index, method='bfill')  # Lookahead bias\ndf = df.reindex(target_index)  # Missing data\n```\n\n---\n\n## Stock Selection Patterns\n\n### Pattern 1: Limit to Top X% of Indicator\n\n```python\n# Select stocks in top 30% by momentum\nmomentum = close / close.shift(60) - 1\ntop_momentum = momentum.rank(axis=1, pct=True) > 0.7\n```\n\n### Pattern 1b: Stable Percentile Ranking with `valid=`\n\nWhen using `fillna()` before ranking (e.g. to compute indicators like SLOPE), the filled values inflate the rank denominator and shift all percentiles. Use `valid=` to exclude them:\n\n```python\nratio = close / close.shift(5)\n# fillna(1) needed for SLOPE, but those cells shouldn't count in rank\nscore = ratio.fillna(1).apply(lambda s: talib.LINEARREG_SLOPE(s, timeperiod=5))\npct = score.rank(axis=1, pct=True, valid=ratio.notna())\n```\n\n### Pattern 2: Limit to Top N Stocks\n\n```python\n# Select top 10 stocks with lowest P/B ratio\npb = data.get(\"price_earning_ratio:ËÇ°ÂÉπÊ∑®ÂÄºÊØî\")\nposition = pb.is_smallest(10)\n\n# Select top 15 stocks meeting a condition\nvolume = data.get(\"price:Êàê‰∫§ËÇ°Êï∏\")\nliquid_stocks = volume.average(20) > 1000*1000\nposition = pb[liquid_stocks].is_smallest(15)\n```\n\n### Pattern 3: Entry/Exit with `hold_until()`\n\n```python\nclose = data.get(\"price:Êî∂Áõ§ÂÉπ\")\npb = data.get(\"price_earning_ratio:ËÇ°ÂÉπÊ∑®ÂÄºÊØî\")\n\n# Define entry and exit signals\nentries = close > close.average(20)\nexits = close < close.average(60)\n\n# Hold until exit, limit to 10 stocks, rank by negative P/B\nposition = entries.hold_until(\n    exits,\n    nstocks_limit=10,\n    rank=-pb  # Negative for ascending order (low P/B preferred)\n)\n```\n\n### Pattern 4: Industry Ranking\n\n```python\n# Select top 20% within each industry\nroe = data.get(\"fundamental_features:ROEÁ®ÖÂæå\")\nindustry_top = roe.industry_rank() > 0.8\n```\n\n---\n\n## Backtesting Patterns\n\n### Pattern 1: Basic Backtest\n\n```python\nsim(position, resample=\"M\")\n```\n\n### Pattern 2: Backtest Within Date Range\n\n```python\nsim(position.loc['2020':'2023'], resample=\"M\")\n```\n\n### Pattern 3: Optuna Parameter Optimization\n\n```python\nimport optuna\nfrom finlab.backtest import sim\n\ndef run_strategy(params):\n    \"\"\"Strategy function that returns a report\"\"\"\n    sma_short = close.average(params['short'])\n    sma_long = close.average(params['long'])\n    position = (sma_short > sma_long)\n    report = sim(position, resample=\"M\", upload=False)\n    return report\n\ndef objective(trial):\n    params = {\n        'short': trial.suggest_int('short', 5, 30),\n        'long': trial.suggest_int('long', 40, 120)\n    }\n    report = run_strategy(params)\n    return report.metrics.sharpe_ratio()\n\n# Optimize with n_trials <= 10\nstudy = optuna.create_study(direction='maximize')\nstudy.optimize(objective, n_trials=10)\nprint(f\"Best params: {study.best_params}\")\n```\n\n### Pattern 4: Evaluate Strategy Condition Coverage\n\n```python\n# Check how often the condition is True (on average across stocks)\ncondition = close > close.average(60)\ncoverage = condition.sum(axis=1).loc['2020':].mean()\nprint(f\"Average stocks meeting condition: {coverage:.1f}\")\n```\n\n### Pattern 5: Adjust Rebalance Frequency\n\n```python\n# Weekly\nsim(position, resample=\"W\")\n\n# Monthly\nsim(position, resample=\"M\")\n\n# Quarterly\nsim(position, resample=\"Q\")\n\n# Custom: use monthly revenue index\nrev = data.get('monthly_revenue:Áï∂ÊúàÁáüÊî∂')\nsim(position, resample=rev.index)\n```\n\n### Pattern 6: Adjust Rebalance Offset\n\n```python\n# Rebalance 1 week after period start\nsim(position, resample=\"M\", resample_offset=\"1W\")\n\n# Rebalance 1 month after quarter start\nsim(position, resample=\"Q\", resample_offset=\"1M\")\n```\n\n---\n\n## Error Handling\n\n### Error: `_ArrayMemoryError`\n\n**Solution:** Reset kernel and try again.\n\n```python\n# Call this if you encounter _ArrayMemoryError\nresetKernel()\n```\n\n### Error: `requests.exceptions.ConnectionError`\n\n**Solution:** Reset kernel and retry.\n\n```python\nresetKernel()\n```\n\n### Error: Áî®ÈáèË∂ÖÈôê (Quota Exceeded)\n\n**Â∏∏Ë¶ãË®äÊÅØ:** `quota exceeded`, `daily limit reached`, `Áî®ÈáèÂ∑≤ÈÅî‰∏äÈôê`\n\n**Ëß£Ê±∫ÊñπÊ°à:**\n\n1. **Á≠âÂæÖÈáçÁΩÆ** - Âè∞ÁÅ£ÊôÇÈñìÊó©‰∏ä 8 ÈªûÊúÉËá™ÂãïÈáçÁΩÆÁî®Èáè\n2. **ÂçáÁ¥ö VIP** - ÂÖçË≤ªÁâà 500 MBÔºåVIP Áâà 5000 MBÔºà10 ÂÄçÔºâ\n\n**ÂëäÁü•Áî®Êà∂:**\n```\nÊÇ®‰ªäÊó•ÁöÑË≥áÊñôÁî®ÈáèÂ∑≤ÈÅî‰∏äÈôêÔºàÂÖçË≤ªÁâà 500 MBÔºâ„ÄÇ\nÊÇ®ÂèØ‰ª•Ôºö\n1. Á≠âÂæÖÂè∞ÁÅ£ÊôÇÈñìÊó©‰∏ä 8 ÈªûËá™ÂãïÈáçÁΩÆ\n2. ÂçáÁ¥ö VIP ‰∫´Êúâ 5000 MB È°çÂ∫¶Ôºà10 ÂÄçÊèêÂçáÔºâ\n\nüëâ ÂçáÁ¥ö VIP: https://www.finlab.finance/payment\n```\n\n**ÊúÄ‰Ω≥ÂåñÁî®ÈáèÁöÑÂª∫Ë≠∞:**\n- ÈÅøÂÖçÈáçË§áÂèñÂæóÁõ∏ÂêåÊï∏ÊìöÔºåÂ∞áÂ∏∏Áî®Êï∏ÊìöÂ≠òÂÖ•ËÆäÊï∏\n- ‰ΩøÁî® `data.universe()` ÈôêÂà∂ÂèñÂæóÁöÑËÇ°Á•®ÁØÑÂúç\n- Ê∏õÂ∞ë‰∏çÂøÖË¶ÅÁöÑÊ≠∑Âè≤Êï∏ÊìöÁØÑÂúç\n\n### Debugging Tips\n\n1. **Break down experiments into small steps**\n\n   ```python\n   # Step 1: Fetch data\n   close = data.get(\"price:Êî∂Áõ§ÂÉπ\")\n   print(close.head())\n\n   # Step 2: Create condition\n   condition = close > close.average(60)\n   print(condition.head())\n\n   # Step 3: Select stocks\n   position = condition.is_largest(10)\n   print(position.head())\n   ```\n\n2. **Inspect variable values** after each step to ensure correctness.\n\n3. **Use print statements** to display intermediate DataFrames.\n\n---\n\n## Strategy Design Principles\n\n### Principle 1: Be Systematic\n\n- **Good:** Clearly define hypothesis, experiment setup, and evaluation criteria\n- **Good:** Import optuna to systematically explore parameter space\n- **Bad:** Randomly changing parameters without a clear plan\n\n### Principle 2: Start Simple\n\n- Begin with a baseline strategy\n- Add complexity incrementally\n- Test each addition separately\n\n### Principle 3: Write Clear, Maintainable Code\n\n- Use descriptive variable names\n- Add comments where logic isn't self-evident\n- Don't over-comment obvious operations\n\n---\n\n## Complete Pattern Examples\n\n### Example 1: Value + Momentum + Liquidity\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\n# Fetch data\nclose = data.get(\"price:Êî∂Áõ§ÂÉπ\")\npb = data.get(\"price_earning_ratio:ËÇ°ÂÉπÊ∑®ÂÄºÊØî\")\nvolume = data.get(\"price:Êàê‰∫§ËÇ°Êï∏\")\n\n# Create factors\nvalue = pb.rank(axis=1, pct=True) < 0.3  # Low P/B\nmomentum = close.rise(20)  # Rising\nliquidity = volume.average(20) > 500*1000  # Liquid\n\n# Combine\nposition = value & momentum & liquidity\nposition = pb[position].is_smallest(10)\n\n# Backtest\nreport = sim(position, resample=\"M\", stop_loss=0.08, upload=False)\nprint(f\"Annual Return: {report.metrics.annual_return():.2%}\")\nprint(f\"Sharpe Ratio: {report.metrics.sharpe_ratio():.2f}\")\nprint(f\"Max Drawdown: {report.metrics.max_drawdown():.2%}\")\n```\n\n### Example 2: Monthly Revenue Growth\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\n# Fetch revenue data\nrev = data.get(\"monthly_revenue:Áï∂ÊúàÁáüÊî∂\")\nrev_growth = data.get(\"monthly_revenue:ÂéªÂπ¥ÂêåÊúàÂ¢ûÊ∏õ(%)\")\n\n# Revenue momentum\nrev_ma3 = rev.average(3)\nrev_high = (rev_ma3 / rev_ma3.rolling(12).max()) == 1\n\n# Sustained growth\nstrong_growth = (rev_growth > 20).sustain(3)\n\n# Combine\nposition = rev_high & strong_growth\nposition = rev_growth[position].is_largest(10)\n\n# Reindex to monthly revenue dates\nposition_resampled = position.reindex(rev.index_str_to_date().index, method=\"ffill\")\n\n# Backtest\nreport = sim(position_resampled, upload=False)\n```\n\n---\n\n## See Also\n\n- [SKILL.md](SKILL.md) - Overview and quick start\n- [dataframe-reference.md](dataframe-reference.md) - FinLabDataFrame methods\n- [backtesting-reference.md](backtesting-reference.md) - Complete `sim()` API\n- [factor-examples.md](factor-examples.md) - 60+ complete examples\n",
  "data-reference": "# Data Reference\n\n## Overview\n\nThe FinLab data module provides comprehensive access to Taiwan stock market data, including prices, financial statements, fundamental metrics, institutional trading, and economic indicators. Use `data.get()` to retrieve any dataset using a simple path-based syntax.\n\n---\n\n## Table of Contents\n\n- [Usage](#usage) - Basic data retrieval with `data.get()`\n- [Data Discovery](#data-discovery) - Find datasets with `data.search()`\n- [Technical Indicators](#technical-indicators) - Compute indicators with `data.indicator()`\n- [Universe Filtering](#universe-filtering) - Filter by market/category\n- [Data Catalog](#data-catalog) - Complete dataset reference\n- [Storage Configuration](#storage-configuration) - Cache and storage settings\n- [Plotting Data](#plotting-data) - Visualization examples\n\n---\n\n## Usage\n\n### Basic Syntax\n\n```python\nfrom finlab import data\n\n# Retrieve data using TABLE:COLUMN format\ndf = data.get('price:Êî∂Áõ§ÂÉπ')\n\n# For tables without columns, use TABLE directly\ninventory = data.get('inventory')\n```\n\n### Data Path Construction\n\nThe path is constructed using colons (`:`) to navigate hierarchical data structures:\n\n**Format:**\n- `<TABLE>:<COLUMN>` - For tables with multiple columns\n- `<TABLE>` - For tables without column structure\n\n**Example:**\n```python\n# Get closing price\nclosing_price = data.get('price:Êî∂Áõ§ÂÉπ')\n\n# Get earnings per share\neps = data.get('financial_statement:ÊØèËÇ°ÁõàÈ§ò')\n\n# Get foreign investor trading volume\nforeign_investment = data.get('institutional_investors_trading_summary:Â§ñÈô∏Ë≥áË≤∑Ë≥£Ë∂ÖËÇ°Êï∏(‰∏çÂê´Â§ñË≥áËá™ÁáüÂïÜ)')\n```\n\n### Common Field Names\n\n| Term | Field |\n|------|-------|\n| EPS | `financial_statement:ÊØèËÇ°ÁõàÈ§ò` |\n| Êú¨ÁõäÊØî | `price_earning_ratio:Êú¨ÁõäÊØî` |\n| ËÇ°ÂÉπÊ∑®ÂÄºÊØî | `price_earning_ratio:ËÇ°ÂÉπÊ∑®ÂÄºÊØî` |\n| ÊÆñÂà©Áéá | `price_earning_ratio:ÊÆñÂà©Áéá(%)` |\n| ROE | `fundamental_features:ROEÁ®ÖÂæå` |\n| ÊØõÂà©Áéá | `fundamental_features:ÁáüÊ•≠ÊØõÂà©Áéá` |\n| ÊúàÁáüÊî∂ | `monthly_revenue:Áï∂ÊúàÁáüÊî∂` |\n| ÁáüÊî∂Âπ¥Â¢ûÁéá | `monthly_revenue:ÂéªÂπ¥ÂêåÊúàÂ¢ûÊ∏õ(%)` |\n\n---\n\n## Data Discovery\n\nUse `data.search()` to programmatically find datasets from the Data Catalog.\n\n**Signature:**\n```python\ndata.search(keyword: str = None, market: str = 'tw') -> list\n```\n\n**Parameters:**\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `keyword` | str | None | Filter datasets by keyword (case-insensitive substring match). Returns all if omitted. |\n| `market` | str | 'tw' | Market to search: `'tw'` (Taiwan stocks), `'us'` (US stocks, testing), or `'all'` (both markets). |\n\n**Returns:** List of `\"table:column\"` strings, usable directly with `data.get()`.\n\n**Examples:**\n```python\nfrom finlab import data\n\n# List all available datasets (Taiwan market)\nall_data = data.search()\n\n# Search by keyword\ndata.search('Êî∂Áõ§')    # ['price:Êî∂Áõ§ÂÉπ']\ndata.search('ÁáüÊî∂')    # ['monthly_revenue:Áï∂ÊúàÁáüÊî∂', ...]\n\n# Search US market data (testing)\ndata.search('close', market='us')\n\n# Use result with data.get()\nresults = data.search('Êî∂Áõ§')\ndf = data.get(results[0])\n```\n\n---\n\n## Technical Indicators\n\nUse `data.indicator()` to compute technical indicators using TA-Lib. Returns a FinLabDataFrame with the same structure as price data (date index, stock columns).\n\n**Signature:**\n```python\ndata.indicator(\n    indname: str,\n    adjust_price: bool = False,\n    resample: str = 'D',\n    **kwargs\n) -> FinLabDataFrame | tuple\n```\n\n**Parameters:**\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `indname` | str | required | Indicator name: `SMA`, `EMA`, `RSI`, `MACD`, `STOCH`, `BBANDS`, `ATR`, `ADX`, etc. |\n| `adjust_price` | bool | False | Use adjusted prices for calculation. |\n| `resample` | str | 'D' | Data frequency: `'D'` (daily), `'W'` (weekly), `'M'` (monthly). |\n| `**kwargs` | - | - | Indicator-specific parameters (e.g., `timeperiod`, `fastperiod`, `slowperiod`). |\n\n**Returns:**\n- Single indicator (SMA, RSI, etc.): `FinLabDataFrame`\n- Multi-output indicator (STOCH, MACD, BBANDS): `tuple` of `FinLabDataFrame`\n\n**Common Indicators:**\n\n| Indicator | Parameters | Returns | Description |\n|-----------|------------|---------|-------------|\n| `SMA` | `timeperiod=30` | DataFrame | Simple Moving Average |\n| `EMA` | `timeperiod=30` | DataFrame | Exponential Moving Average |\n| `RSI` | `timeperiod=14` | DataFrame | Relative Strength Index (0-100) |\n| `STOCH` | `fastk_period=5, slowk_period=3, slowd_period=3` | (k, d) tuple | Stochastic Oscillator |\n| `MACD` | `fastperiod=12, slowperiod=26, signalperiod=9` | (macd, signal, hist) tuple | MACD |\n| `BBANDS` | `timeperiod=5, nbdevup=2, nbdevdn=2` | (upper, middle, lower) tuple | Bollinger Bands |\n| `ATR` | `timeperiod=14` | DataFrame | Average True Range |\n| `ADX` | `timeperiod=14` | DataFrame | Average Directional Index |\n\n**Examples:**\n```python\nfrom finlab import data\n\n# Simple moving average\nsma20 = data.indicator('SMA', timeperiod=20)\nsma60 = data.indicator('SMA', timeperiod=60)\n\n# RSI\nrsi = data.indicator('RSI', timeperiod=14)\noversold = rsi < 30\n\n# Stochastic oscillator (returns tuple)\nk, d = data.indicator('STOCH', adjust_price=True)\n\n# MACD (returns tuple)\nmacd, signal, hist = data.indicator('MACD')\n\n# Bollinger Bands (returns tuple)\nupper, middle, lower = data.indicator('BBANDS', timeperiod=20)\n\n# Weekly RSI\nrsi_weekly = data.indicator('RSI', timeperiod=14, resample='W')\n```\n\n---\n\n## Universe Filtering\n\nLimit the data fetch scope by market or industry category using a context manager or global settings.\n\n### Supported Markets\n- `ALL` - All markets\n- `TSE` - Taiwan Stock Exchange (‰∏äÂ∏Ç)\n- `OTC` - Over-The-Counter (‰∏äÊ´É)\n- `TSE_OTC` - Both TSE and OTC\n- `ETF` - Exchange Traded Funds\n\n### Supported Categories\n\n**Industry Categories:**\nÂÖâÈõªÊ•≠, ÂÖ∂‰ªñ, ÂÖ∂‰ªñÈõªÂ≠êÊ•≠, ÂåñÂ≠∏Â∑•Ê•≠, ÂçäÂ∞éÈ´î, Â°ëËÜ†Â∑•Ê•≠, Â≠òË®óÊÜëË≠â, Âª∫ÊùêÁáüÈÄ†, ÊñáÂåñÂâµÊÑèÊ•≠, Ê©°ËÜ†Â∑•Ê•≠, Ê∞¥Ê≥•Â∑•Ê•≠, Ê±ΩËªäÂ∑•Ê•≠, Ê≤πÈõªÁáÉÊ∞£Ê•≠, ÁéªÁíÉÈô∂Áì∑, ÁîüÊäÄÈÜ´ÁôÇ, ÁîüÊäÄÈÜ´ÁôÇÊ•≠, Á¥°ÁπîÁ∫ñÁ∂≠, Ëà™ÈÅãÊ•≠, ËßÄÂÖâ‰∫ãÊ•≠, Ë≤øÊòìÁôæË≤®, Ë≥áË®äÊúçÂãôÊ•≠, Ëæ≤Ê•≠ÁßëÊäÄ, ÈÄö‰ø°Á∂≤Ë∑ØÊ•≠, ÈÄ†Á¥ôÂ∑•Ê•≠, ÈáëËûç, ÈãºÈêµÂ∑•Ê•≠, ÈõªÂô®ÈõªÁ∫ú, ÈõªÂ≠êÂïÜÂãô, ÈõªÂ≠êÈÄöË∑ØÊ•≠, ÈõªÂ≠êÈõ∂ÁµÑ‰ª∂, ÈõªÊ©üÊ©üÊ¢∞, ÈõªËÖ¶ÂèäÈÄ±ÈÇä, È£üÂìÅÂ∑•Ê•≠\n\n**ETF Categories:**\ndomestic_etf, foreign_etf, leveraged_etf, vanilla_futures_etf, leveraged_futures_etf\n\n### Parameters\n\n- `market` (str): One of 'ALL', 'TSE', 'OTC', 'TSE_OTC', 'ETF'\n- `category` (str or list): Industry NAMES only (no numeric codes); supports regex fuzzy match (e.g. 'ÈõªÂ≠ê' matches multiple electronics categories)\n- `exclude_category` (str or list or None): Excluded industry NAMES only (no numeric codes); same regex rules as category\n\n### Important Notes\n\n- Regex matching is used for categories. To match exact 'ÂÖ∂‰ªñ', use '^ÂÖ∂‰ªñ$'\n- When both category and exclude_category are provided, select category first, then subtract exclude_category\n- Use data.universe ONLY to scope data.get() or backtest.sim() ‚Äî do NOT wrap DataFrame/factor operations (e.g., position = ...)\n- Do NOT use category codes (‰ª£Ëôü) like '28'; use industry names instead (e.g., exclude_category='ÈáëËûç')\n\n### Examples\n\n**Context Manager (Recommended):**\n```python\nfrom finlab import data\n\n# Filter by market and category\nwith data.universe(market='TSE_OTC', category=['Ê∞¥Ê≥•Â∑•Ê•≠']):\n    price = data.get('price:Êî∂Áõ§ÂÉπ')\n\n# Exact match using regex\nwith data.universe(market='TSE_OTC', category=['^ÂÖ∂‰ªñ$']):\n    close_subset = data.get('price:Êî∂Áõ§ÂÉπ')\n\n# Exclude specific categories\nwith data.universe(market='TSE_OTC', category=['Ê∞¥Ê≥•Â∑•Ê•≠'], exclude_category=['ÈáëËûç']):\n    price = data.get('price:Êî∂Áõ§ÂÉπ')\n```\n\n**Global Setting:**\n```python\nfrom finlab import data\n\ndata.set_universe(market='TSE_OTC', category='Ê∞¥Ê≥•Â∑•Ê•≠', exclude_category='ÈáëËûç')\nprice = data.get('price:Êî∂Áõ§ÂÉπ')\n```\n\n---\n\n## Data Catalog\n\n### Price & Trading Data\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `price` | ‰∏äÂ∏ÇÊ´ÉÂ∏ÇÂ†¥Êàê‰∫§Ë≥áË®ä | Êàê‰∫§ËÇ°Êï∏, Êàê‰∫§Á≠ÜÊï∏, Êàê‰∫§ÈáëÈ°ç, Êî∂Áõ§ÂÉπ, ÈñãÁõ§ÂÉπ, ÊúÄ‰ΩéÂÉπ, ÊúÄÈ´òÂÉπ, ÊúÄÂæåÊè≠Á§∫Ë≤∑ÂÉπ, ÊúÄÂæåÊè≠Á§∫Ë≥£ÂÉπ, ÊúÄÂæåÊè≠Á§∫Ë≤∑Èáè, ÊúÄÂæåÊè≠Á§∫Ë≥£Èáè |\n| `etl` | ÈÇÑÂéüÊ¨äÂÄºËÇ°ÂÉπ | adj_close, adj_open, adj_high, adj_low |\n| `intraday_odd_lot_trade` | ‰∏äÂ∏ÇÊ´ÉÁõ§‰∏≠Èõ∂ËÇ°Êàê‰∫§Ë≥áË®ä | Êàê‰∫§ËÇ°Êï∏, Êàê‰∫§Á≠ÜÊï∏, Êàê‰∫§ÈáëÈ°ç, Êî∂Áõ§ÂÉπ, ÈñãÁõ§ÂÉπ, ÊúÄ‰ΩéÂÉπ, ÊúÄÈ´òÂÉπ, ÊúÄÂæåÊè≠Á§∫Ë≤∑ÂÉπ, ÊúÄÂæåÊè≠Á§∫Ë≥£ÂÉπ, ÊúÄÂæåÊè≠Á§∫Ë≤∑Èáè, ÊúÄÂæåÊè≠Á§∫Ë≥£Èáè |\n| `after_market_odd_lot_trade` | ‰∏äÂ∏ÇÊ´ÉÁõ§ÂæåÈõ∂ËÇ°Êàê‰∫§Ë≥áË®ä | Êàê‰∫§ËÇ°Êï∏, Êàê‰∫§Á≠ÜÊï∏, Êàê‰∫§ÈáëÈ°ç, Êàê‰∫§ÂÉπ, ÊúÄÂæåÊè≠Á§∫Ë≤∑ÂÉπ, ÊúÄÂæåÊè≠Á§∫Ë≥£ÂÉπ, ÊúÄÂæåÊè≠Á§∫Ë≤∑Èáè, ÊúÄÂæåÊè≠Á§∫Ë≥£Èáè |\n| `intraday_trading` | ÁèæËÇ°Áï∂Ê≤ñÊàê‰∫§Ë≥áË®ä | Áï∂Êó•Ê≤ñÈä∑‰∫§ÊòìÊàê‰∫§ËÇ°Êï∏, Áï∂Êó•Ê≤ñÈä∑‰∫§ÊòìË≤∑ÈÄ≤Êàê‰∫§ÈáëÈ°ç, Áï∂Êó•Ê≤ñÈä∑‰∫§ÊòìË≥£Âá∫Êàê‰∫§ÈáëÈ°ç, ÂæóÂÖàË≥£ÂæåË≤∑Áï∂Ê≤ñ |\n| `rotc_price` | ËààÊ´ÉÂ∏ÇÂ†¥Êàê‰∫§Ë≥áË®ä | Êàê‰∫§ËÇ°Êï∏, Êàê‰∫§ÈáëÈ°ç, ÈñãÁõ§ÂÉπ, Êî∂Áõ§ÂÉπ, ÊúÄÈ´òÂÉπ, ÊúÄ‰ΩéÂÉπ, Êó•ÂùáÂÉπ, Êàê‰∫§Á≠ÜÊï∏, ÊúÄÂæåÊè≠Á§∫Ë≤∑ÂÉπ, ÊúÄÂæåÊè≠Á§∫Ë≥£ÂÉπ |\n\n### Valuation Metrics\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `price_earning_ratio` | ÂÄãËÇ°Êó•Êú¨ÁõäÊØî„ÄÅÊÆñÂà©ÁéáÂèäËÇ°ÂÉπÊ∑®ÂÄºÊØî | ÊÆñÂà©Áéá(%), Êú¨ÁõäÊØî, ËÇ°ÂÉπÊ∑®ÂÄºÊØî |\n| `etl` | ÂÄãËÇ°Â∏ÇÂÄº | market_value |\n\n### Revenue Data\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `monthly_revenue` | ‰∏äÂ∏ÇÊ´ÉÊúàÁáüÊî∂ | Áï∂ÊúàÁáüÊî∂, ‰∏äÊúàÁáüÊî∂, ÂéªÂπ¥Áï∂ÊúàÁáüÊî∂, ‰∏äÊúàÊØîËºÉÂ¢ûÊ∏õ(%), ÂéªÂπ¥ÂêåÊúàÂ¢ûÊ∏õ(%), Áï∂ÊúàÁ¥ØË®àÁáüÊî∂, ÂéªÂπ¥Á¥ØË®àÁáüÊî∂, ÂâçÊúüÊØîËºÉÂ¢ûÊ∏õ(%) |\n| `rotc_monthly_revenue` | ËààÊ´ÉÊúàÁáüÊî∂ | Áï∂ÊúàÁáüÊî∂, ‰∏äÊúàÁáüÊî∂, ÂéªÂπ¥Áï∂ÊúàÁáüÊî∂, ‰∏äÊúàÊØîËºÉÂ¢ûÊ∏õ(%), ÂéªÂπ¥ÂêåÊúàÂ¢ûÊ∏õ(%), Áï∂ÊúàÁ¥ØË®àÁáüÊî∂, ÂéªÂπ¥Á¥ØË®àÁáüÊî∂, ÂâçÊúüÊØîËºÉÂ¢ûÊ∏õ(%), ÂÇôË®ª |\n\n### Financial Statements\n\nThe `financial_statement` table contains comprehensive balance sheet, income statement, and cash flow data with 100+ columns including:\n\n**Balance Sheet Items:**\n- Assets: ÁèæÈáëÂèäÁ¥ÑÁï∂ÁèæÈáë, ÊµÅÂãïË≥áÁî¢, ÈùûÊµÅÂãïË≥áÁî¢, Ë≥áÁî¢Á∏ΩÈ°ç\n- Liabilities: ÊµÅÂãïË≤†ÂÇµ, ÈùûÊµÅÂãïË≤†ÂÇµ, Ë≤†ÂÇµÁ∏ΩÈ°ç\n- Equity: ËÇ°Êú¨, Ë≥áÊú¨ÂÖ¨Á©çÂêàË®à, ‰øùÁïôÁõàÈ§ò, ËÇ°Êù±Ê¨äÁõäÁ∏ΩÈ°ç\n\n**Income Statement Items:**\n- Revenue & Costs: ÁáüÊ•≠Êî∂ÂÖ•Ê∑®È°ç, ÁáüÊ•≠ÊàêÊú¨, ÁáüÊ•≠ÊØõÂà©\n- Expenses: Á†îÁ©∂ÁôºÂ±ïË≤ª, Êé®Èä∑Ë≤ªÁî®, ÁÆ°ÁêÜË≤ªÁî®\n- Profit: ÁáüÊ•≠Âà©Áõä, Á®ÖÂâçÊ∑®Âà©, Ê≠∏Â±¨ÊØçÂÖ¨Âè∏Ê∑®Âà©(Êêç), ÊØèËÇ°ÁõàÈ§ò\n\n**Cash Flow Items:**\n- Operating: ÁáüÊ•≠Ê¥ªÂãï‰πãÊ∑®ÁèæÈáëÊµÅÂÖ•(ÊµÅÂá∫)\n- Investing: ÊäïË≥áÊ¥ªÂãï‰πãÊ∑®ÁèæÈáëÊµÅÂÖ•(ÊµÅÂá∫), ÂèñÂæó‰∏çÂãïÁî¢_Âª†ÊàøÂèäË®≠ÂÇô\n- Financing: Á±åË≥áÊ¥ªÂãï‰πãÊ∑®ÁèæÈáëÊµÅÂÖ•(ÊµÅÂá∫), ÁôºÊîæÁèæÈáëËÇ°Âà©\n\n### Fundamental Features\n\nThe `fundamental_features` table contains 50+ calculated financial metrics:\n\n**Profitability Metrics:**\n- ROAÁ®ÖÂæåÊÅØÂâç, ROAÁ∂úÂêàÊêçÁõä, ROEÁ®ÖÂæå, ROEÁ∂úÂêàÊêçÁõä\n- ÁáüÊ•≠ÊØõÂà©Áéá, ÁáüÊ•≠Âà©ÁõäÁéá, Á®ÖÂâçÊ∑®Âà©Áéá, Á®ÖÂæåÊ∑®Âà©Áéá\n\n**Growth Metrics:**\n- ÁáüÊî∂ÊàêÈï∑Áéá, ÁáüÊ•≠ÊØõÂà©ÊàêÈï∑Áéá, ÁáüÊ•≠Âà©ÁõäÊàêÈï∑Áéá, Á®ÖÂâçÊ∑®Âà©ÊàêÈï∑Áéá, Á®ÖÂæåÊ∑®Âà©ÊàêÈï∑Áéá\n\n**Efficiency Metrics:**\n- Á∏ΩË≥áÁî¢ÈÄ±ËΩâÊ¨°Êï∏, ÊáâÊî∂Â∏≥Ê¨æÈÄ±ËΩâÁéá, Â≠òË≤®ÈÄ±ËΩâÁéá, Âõ∫ÂÆöË≥áÁî¢ÈÄ±ËΩâÊ¨°Êï∏\n\n**Liquidity Metrics:**\n- ÊµÅÂãïÊØîÁéá, ÈÄüÂãïÊØîÁéá, ÁèæÈáëÊµÅÈáèÊØîÁéá\n\n**Leverage Metrics:**\n- Ë≤†ÂÇµÊØîÁéá, Á∏ΩË≤†ÂÇµÈô§Á∏ΩÊ∑®ÂÄº\n\n**Per Share Metrics:**\n- ÊØèËÇ°ÁáüÊ•≠È°ç, ÊØèËÇ°ÁáüÊ•≠Âà©Áõä, ÊØèËÇ°ÁèæÈáëÊµÅÈáè, ÊØèËÇ°Á®ÖÂâçÊ∑®Âà©, ÊØèËÇ°Á∂úÂêàÊêçÁõä, ÊØèËÇ°Á®ÖÂæåÊ∑®Âà©\n\n### Institutional Trading\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `institutional_investors_trading_summary` | ‰∏âÂ§ßÊ≥ï‰∫∫Ë≤∑Ë≥£Ë∂Ö | Â§ñÈô∏Ë≥áË≤∑ÈÄ≤ËÇ°Êï∏(‰∏çÂê´Â§ñË≥áËá™ÁáüÂïÜ), Â§ñÈô∏Ë≥áË≥£Âá∫ËÇ°Êï∏(‰∏çÂê´Â§ñË≥áËá™ÁáüÂïÜ), Â§ñÈô∏Ë≥áË≤∑Ë≥£Ë∂ÖËÇ°Êï∏(‰∏çÂê´Â§ñË≥áËá™ÁáüÂïÜ), Â§ñË≥áËá™ÁáüÂïÜË≤∑ÈÄ≤ËÇ°Êï∏, Â§ñË≥áËá™ÁáüÂïÜË≥£Âá∫ËÇ°Êï∏, Â§ñË≥áËá™ÁáüÂïÜË≤∑Ë≥£Ë∂ÖËÇ°Êï∏, Êäï‰ø°Ë≤∑ÈÄ≤ËÇ°Êï∏, Êäï‰ø°Ë≥£Âá∫ËÇ°Êï∏, Êäï‰ø°Ë≤∑Ë≥£Ë∂ÖËÇ°Êï∏, Ëá™ÁáüÂïÜË≤∑ÈÄ≤ËÇ°Êï∏(Ëá™Ë°åË≤∑Ë≥£), Ëá™ÁáüÂïÜË≥£Âá∫ËÇ°Êï∏(Ëá™Ë°åË≤∑Ë≥£), Ëá™ÁáüÂïÜË≤∑Ë≥£Ë∂ÖËÇ°Êï∏(Ëá™Ë°åË≤∑Ë≥£), Ëá™ÁáüÂïÜË≤∑ÈÄ≤ËÇ°Êï∏(ÈÅøÈö™), Ëá™ÁáüÂïÜË≥£Âá∫ËÇ°Êï∏(ÈÅøÈö™), Ëá™ÁáüÂïÜË≤∑Ë≥£Ë∂ÖËÇ°Êï∏(ÈÅøÈö™) |\n| `foreign_investors_shareholding` | Â§ñË≥áÊåÅËÇ°ÊØîÁéá | ÁôºË°åËÇ°Êï∏, Â§ñË≥áÂèäÈô∏Ë≥áÂ∞öÂèØÊäïË≥áËÇ°Êï∏, ÂÖ®È´îÂ§ñË≥áÂèäÈô∏Ë≥áÊåÅÊúâËÇ°Êï∏, Â§ñË≥áÂèäÈô∏Ë≥áÂ∞öÂèØÊäïË≥áÊØîÁéá, ÂÖ®È´îÂ§ñË≥áÂèäÈô∏Ë≥áÊåÅËÇ°ÊØîÁéá, Â§ñË≥áÂèäÈô∏Ë≥áÂÖ±Áî®Ê≥ï‰ª§ÊäïË≥á‰∏äÈôêÊØîÁéá, Èô∏Ë≥áÊ≥ï‰ª§ÊäïË≥á‰∏äÈôêÊØîÁéá |\n\n### Margin Trading\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `margin_transactions` | ËûçË≥áÂà∏ | ËûçË≥áË≤∑ÈÄ≤, ËûçË≥áË≥£Âá∫, ËûçË≥áÁèæÈáëÂÑüÈÇÑ, ËûçË≥áÂâçÊó•È§òÈ°ç, ËûçË≥á‰ªäÊó•È§òÈ°ç, ËûçË≥áÈôêÈ°ç, ËûçÂà∏Ë≤∑ÈÄ≤, ËûçÂà∏Ë≥£Âá∫, ËûçÂà∏ÁèæÂà∏ÂÑüÈÇÑ, ËûçÂà∏ÂâçÊó•È§òÈ°ç, ËûçÂà∏‰ªäÊó•È§òÈ°ç, ËûçÂà∏ÈôêÈ°ç, Ë≥áÂà∏‰∫íÊäµ, Ë®ªË®ò, ËûçË≥á‰ΩøÁî®Áéá, ËûçÂà∏‰ΩøÁî®Áéá |\n| `security_lending` | ÂÄüÂà∏ | ÂâçÊó•ÂÄüÂà∏È§òÈ°ç, ÂÄüÂà∏, ÂÄüÂà∏ÈÇÑÂà∏, ÂÄüÂà∏Â¢ûÊ∏õ, ÂÄüÂà∏È§òÈ°ç |\n| `security_lending_sell` | ÂÄüÂà∏Ë≥£Âá∫ | ÂÄüÂà∏Ë≥£Âá∫, ÂÄüÂà∏Ë≥£Âá∫ÈÇÑÂà∏, ÂÄüÂà∏Ë≥£Âá∫È§òÈ°ç, ÂÄüÂà∏Ë≥£Âá∫ÈôêÈ°ç |\n\n### Insider Trading\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `internal_equity_changes` | ÂÖßÈÉ®‰∫∫ÊåÅËÇ°ËÆäÂåñ | ÁôºË°åËÇ°Êï∏, Ëë£Áõ£Â¢ûÂä†ËÇ°Êï∏, Ëë£Áõ£Ê∏õÂ∞ëËÇ°Êï∏, Ëë£Áõ£ÊåÅÊúâËÇ°Êï∏, Ëë£Áõ£ÊåÅÊúâËÇ°Êï∏Âç†ÊØî, Á∂ìÁêÜ‰∫∫ÊåÅÊúâËÇ°Êï∏, ÁôæÂàÜ‰πãÂçÅ‰ª•‰∏äÂ§ßËÇ°Êù±ÊåÅÊúâËÇ°Êï∏, Â∏ÇÂ†¥Âà• |\n| `internal_equity_pledge` | ÂÖßÈÉ®‰∫∫Ë≥™Êäº | Ëë£Áõ£ÊåÅËÇ°, Ëë£Áõ£Ë®≠Ë≥™, Ëë£Áõ£Ëß£Ë≥™, Ëë£Áõ£Á¥ØË®àË®≠Ë≥™, Ëë£Áõ£Ë®≠Ë≥™ËÇ°Êï∏Âç†ÊØî, Á∂ìÁêÜ‰∫∫ÊåÅËÇ°, ÁôæÂàÜ‰πãÂçÅ‰ª•‰∏äÂ§ßËÇ°Êù±ÊåÅÊúâËÇ°Êï∏, Á∂ìÁêÜ‰∫∫ÂèäÁôæÂàÜ‰πãÂçÅ‰ª•‰∏äÂ§ßËÇ°Êù±Ë®≠Ë≥™ËÇ°Êï∏, Á∂ìÁêÜ‰∫∫ÂèäÁôæÂàÜ‰πãÂçÅ‰ª•‰∏äÂ§ßËÇ°Êù±Ë®≠Ë≥™ËÇ°Êï∏Âç†ÊØî, Â∏ÇÂ†¥Âà• |\n| `inventory` | ÈõÜ‰øùÈ§òÈ°ç | (Unstructured table - use directly) |\n\n### Corporate Actions\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `dividend_tse` | ‰∏äÂ∏ÇÈô§Ê¨äÊÅØ | Èô§Ê¨äÊÅØÂâçÊî∂Áõ§ÂÉπ, Èô§Ê¨äÊÅØÂèÉËÄÉÂÉπ, Ê¨äÂÄº+ÊÅØÂÄº, Ê¨äÊÅØ, Êº≤ÂÅúÂÉπÊ†º, Ë∑åÂÅúÂÉπÊ†º, ÈñãÁõ§Á´∂ÂÉπÂü∫Ê∫ñ, Ê∏õÈô§ËÇ°Âà©ÂèÉËÄÉÂÉπ, Ë©≥Á¥∞Ë≥áÊñô, ÊúÄËøë‰∏ÄÊ¨°Áî≥Â†±Ë≥áÊñô Â≠£Âà•Êó•Êúü, ÊúÄËøë‰∏ÄÊ¨°Áî≥Â†±ÊØèËÇ° (ÂñÆ‰Ωç)Ê∑®ÂÄº, ÊúÄËøë‰∏ÄÊ¨°Áî≥Â†±ÊØèËÇ° (ÂñÆ‰Ωç)ÁõàÈ§ò, twse_divide_ratio |\n| `dividend_otc` | ‰∏äÊ´ÉÈô§Ê¨äÊÅØ | Èô§Ê¨äÊÅØÂâçÊî∂Áõ§ÂÉπ, Èô§Ê¨äÊÅØÂèÉËÄÉÂÉπ, Ê¨äÂÄº, ÊÅØÂÄº, Ê¨ä+ÊÅØÂÄº, Ê¨äÊÅØ, Êº≤ÂÅúÂÉπÊ†º, Ë∑åÂÅúÂÉπÊ†º, ÈñãÁõ§Á´∂ÂÉπÂü∫Ê∫ñ, Ê∏õÈô§ËÇ°Âà©ÂèÉËÄÉÂÉπ, ÁèæÈáëËÇ°Âà©, ÊØèÂçÉËÇ°ÁÑ°ÂÑüÈÖçËÇ°, ÁèæÈáëÂ¢ûË≥áËÇ°Êï∏, ÁèæÈáëÂ¢ûË≥áË™çË≥ºÂÉπ, ÂÖ¨ÈñãÊâøÈä∑ËÇ°Êï∏, Âì°Â∑•Ë™çË≥ºËÇ°Êï∏, ÂéüËÇ°Êù±Ë™çË≥ºÊï∏, ÊåâÊåÅËÇ°ÊØî‰æãÂçÉËÇ°Ë™çË≥º, otc_divide_ratio |\n| `capital_reduction_tse` | ‰∏äÂ∏ÇÊ∏õË≥á | ÊÅ¢Âæ©Ë≤∑Ë≥£Êó•Êúü, Ê∏õË≥áÂéüÂõ†, ÊÅ¢Âæ©Ë≤∑Ë≥£ÂèÉËÄÉÂÉπ, ÂÅúÊ≠¢Ë≤∑Ë≥£ÂâçÊî∂Áõ§ÂÉπÊ†º, Êº≤ÂÅúÂÉπÊ†º, Ë∑åÂÅúÂÉπÊ†º, ÈñãÁõ§Á´∂ÂÉπÂü∫Ê∫ñ, Èô§Ê¨äÂèÉËÄÉÂÉπ, twse_cap_divide_ratio |\n| `capital_reduction_otc` | ‰∏äÊ´ÉÊ∏õË≥á | ÊÅ¢Âæ©Ë≤∑Ë≥£Êó•Êúü, Ê∏õË≥áÂéüÂõ†, ÈñãÂßã‰∫§ÊòìÂü∫Ê∫ñÂÉπ, ÊúÄÂæå‰∫§Êòì‰πãÊî∂Áõ§ÂÉπÊ†º, Ê∏õË≥áÊÅ¢Âæ©Ë≤∑Ë≥£ÈñãÂßãÊó•ÂèÉËÄÉÂÉπÊ†º, Êº≤ÂÅúÂÉπÊ†º, Ë∑åÂÅúÂÉπÊ†º, Èô§Ê¨äÂèÉËÄÉÂÉπ, otc_cap_divide_ratio |\n| `treasury_stock` | Â∫´ËóèËÇ° | Ë≤∑ÂõûÁõÆÁöÑ, Ë≤∑ÂõûËÇ°‰ªΩÁ∏ΩÈáëÈ°ç‰∏äÈôê, È†êÂÆöË≤∑ÂõûËÇ°Êï∏, Ë≤∑ÂõûÂÉπÊ†ºÂçÄÈñì-ÊúÄ‰Ωé, Ë≤∑ÂõûÂÉπÊ†ºÂçÄÈñì-ÊúÄÈ´ò, È†êÂÆöË≤∑ÂõûÊúüÈñì-Ëµ∑, È†êÂÆöË≤∑ÂõûÊúüÈñì-ËøÑ, ÊòØÂê¶Âü∑Ë°åÂÆåÁï¢, Êú¨Ê¨°Â∑≤Ë≤∑ÂõûËÇ°Êï∏, Êú¨Ê¨°Âü∑Ë°åÂÆåÁï¢Â∑≤Ë®ªÈä∑ÊàñËΩâËÆìËÇ°Êï∏, Êú¨Ê¨°Â∑≤Ë≤∑ÂõûËÇ°Êï∏‰ΩîÈ†êÂÆöË≤∑ÂõûËÇ°Êï∏ÊØî‰æã(%), Êú¨Ê¨°Â∑≤Ë≤∑ÂõûÁ∏ΩÈáëÈ°ç, Êú¨Ê¨°Âπ≥ÂùáÊØèËÇ°Ë≤∑ÂõûÂÉπÊ†º, Êú¨Ê¨°Ë≤∑ÂõûËÇ°Êï∏‰ΩîÂÖ¨Âè∏Â∑≤ÁôºË°åËÇ°‰ªΩÁ∏ΩÊï∏ÊØî‰æã(%), Êú¨Ê¨°Êú™Âü∑Ë°åÂÆåÁï¢‰πãÂéüÂõ† |\n\n### Market Indices\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `benchmark_return` | ÂõûÊ∏¨Âü∫Ê∫ñ | ÁôºË°åÈáèÂä†Ê¨äËÇ°ÂÉπÂ†±ÈÖ¨ÊåáÊï∏ |\n| `taiex_total_index` | ÁôºË°åÈáèÂä†Ê¨äËÇ°ÂÉπÊåáÊï∏Ê≠∑Âè≤Ë≥áÊñô | ÈñãÁõ§ÊåáÊï∏, ÊúÄÈ´òÊåáÊï∏, ÊúÄ‰ΩéÊåáÊï∏, Êî∂Áõ§ÊåáÊï∏ |\n| `stock_index_price` | ÊåáÊï∏Ë≥áË®ä | Êî∂Áõ§ÊåáÊï∏, Êº≤Ë∑åÁôæÂàÜÊØî(%) |\n| `stock_index_vol` | ÊåáÊï∏Êàê‰∫§ÈáèË≥áË®ä | Êàê‰∫§ËÇ°Êï∏, Êàê‰∫§ÈáëÈ°ç, Êàê‰∫§Á≠ÜÊï∏ |\n| `world_index` | ‰∏ñÁïåÊåáÊï∏ | open, high, low, close, adj_close, volume |\n\n### Economic Indicators\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `tw_business_indicators` | Âè∞ÁÅ£ÊôØÊ∞£ÊåáÊ®ô | ÊôØÊ∞£Â∞çÁ≠ñ‰ø°Ëôü(ÂàÜ), È†òÂÖàÊåáÊ®ôÁ∂úÂêàÊåáÊï∏(Èªû), È†òÂÖàÊåáÊ®ô‰∏çÂê´Ë∂®Âã¢ÊåáÊï∏(Èªû), ÂêåÊôÇÊåáÊ®ôÁ∂úÂêàÊåáÊï∏(Èªû), ÂêåÊôÇÊåáÊ®ô‰∏çÂê´Ë∂®Âã¢ÊåáÊï∏(Èªû), ËêΩÂæåÊåáÊ®ôÁ∂úÂêàÊåáÊï∏(Èªû), ËêΩÂæåÊåáÊ®ô‰∏çÂê´Ë∂®Âã¢ÊåáÊï∏(Èªû) |\n| `tw_total_pmi` | Âè∞ÁÅ£Ë£ΩÈÄ†Ê•≠Êé°Ë≥ºÁ∂ìÁêÜ‰∫∫ÊåáÊï∏ | Ë£ΩÈÄ†Ê•≠PMI, Êñ∞Â¢ûË®ÇÂñÆÊï∏Èáè, ÁîüÁî¢Êï∏Èáè, ‰∫∫ÂäõÂÉ±Áî®Êï∏Èáè, ‰æõÊáâÂïÜ‰∫§Ë≤®ÊôÇÈñì, Â≠òË≤®, ÂÆ¢Êà∂Â≠òË≤®, ÂéüÁâ©ÊñôÂÉπÊ†º, Êú™ÂÆåÊàêË®ÇÂñÆ, Êñ∞Â¢ûÂá∫Âè£Ë®ÇÂñÆ, ÈÄ≤Âè£ÂéüÁâ©ÊñôÊï∏Èáè, Êú™‰æÜÂÖ≠ÂÄãÊúàÂ±ïÊúõ |\n| `tw_total_nmi` | Âè∞ÁÅ£ÈùûË£ΩÈÄ†Ê•≠Êé°Ë≥ºÁ∂ìÁêÜ‰∫∫ÊåáÊï∏ | Ëá∫ÁÅ£ÈùûË£ΩÈÄ†Ê•≠NMI, ÂïÜÊ•≠Ê¥ªÂãï, Êñ∞Â¢ûË®ÇÂñÆ, ‰∫∫ÂäõÂÉ±Áî®, ‰æõÊáâÂïÜ‰∫§Ë≤®ÊôÇÈñì, Â≠òË≤®, Êé°Ë≥ºÂÉπÊ†º, Êú™ÂÆåÊàêË®ÇÂñÆ, ÊúçÂãôËº∏Âá∫Âá∫Âè£, ÊúçÂãôËº∏ÂÖ•ÈÄ≤Âè£, ÊúçÂãôÊî∂Ë≤ªÂÉπÊ†º, Â≠òË≤®ËßÄÊÑü, Êú™‰æÜÂÖ≠ÂÄãÊúàÂ±ïÊúõ |\n| `tw_monetary_aggregates` | Ë≤®Âπ£Á∏ΩË®àÊï∏Âπ¥Â¢ûÁéá | Âπ¥Â¢ûÁéá(%) |\n\n### Futures Data\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `futures_price` | ÊúüË≤®Êó•Êàê‰∫§Ë≥áË®ä | Âà∞ÊúüÊúà‰ªΩ(ÈÄ±Âà•), ÈñãÁõ§ÂÉπ, ÊúÄÈ´òÂÉπ, ÊúÄ‰ΩéÂÉπ, Êî∂Áõ§ÂÉπ, Êº≤Ë∑åÂÉπ, Êº≤Ë∑åÂπÖ, Êàê‰∫§Èáè, Êú™Ê≤ñÈä∑Â•ëÁ¥ÑÊï∏ |\n| `futures_institutional_investors_trading_summary` | ÊúüË≤®‰∏âÂ§ßÊ≥ï‰∫∫Áõ§ÂæåË≥áË®ä | Â§öÊñπ‰∫§ÊòìÂè£Êï∏, Á©∫Êñπ‰∫§ÊòìÂè£Êï∏, Â§öÁ©∫‰∫§ÊòìÂè£Êï∏Ê∑®È°ç, Â§öÊñπÊú™Âπ≥ÂÄâÂè£Êï∏, Á©∫ÊñπÊú™Âπ≥ÂÄâÂè£Êï∏, Â§öÁ©∫Êú™Âπ≥ÂÄâÂè£Êï∏Ê∑®È°ç, Â§öÊñπ‰∫§ÊòìÂ•ëÁ¥ÑÈáëÈ°ç(ÂçÉÂÖÉ), Á©∫Êñπ‰∫§ÊòìÂ•ëÁ¥ÑÈáëÈ°ç(ÂçÉÂÖÉ), Â§öÁ©∫‰∫§ÊòìÂ•ëÁ¥ÑÈáëÈ°çÊ∑®È°ç(ÂçÉÂÖÉ), Â§öÊñπÊú™Âπ≥ÂÄâÂ•ëÁ¥ÑÈáëÈ°ç(ÂçÉÂÖÉ), Á©∫ÊñπÊú™Âπ≥ÂÄâÂ•ëÁ¥ÑÈáëÈ°ç(ÂçÉÂÖÉ), Â§öÁ©∫Êú™Âπ≥ÂÄâÂ•ëÁ¥ÑÈáëÈ°çÊ∑®È°ç(ÂçÉÂÖÉ) |\n\n### Convertible Bonds\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `cb_price` | ÂèØËΩâÊèõÂÖ¨Âè∏ÂÇµÊàê‰∫§Ë≥áË®ä | Êàê‰∫§ÂºµÊï∏, Êàê‰∫§Á≠ÜÊï∏, Êàê‰∫§ÈáëÈ°ç, Êî∂Áõ§ÂÉπ, ÈñãÁõ§ÂÉπ, ÊúÄ‰ΩéÂÉπ, ÊúÄÈ´òÂÉπ |\n| `cb_converted_status` | ÂèØËΩâÊèõÂÖ¨Âè∏ÂÇµÊØèÊúàËΩâÊèõÊôÆÈÄöËÇ° | Êú¨ÊúàËΩâÊèõÂºµÊï∏, ËΩâ(‰∫§)ÊèõÊàñË™çËÇ°ÂÉπÊ†º(ÂÖÉ), ÂÇµÂà∏ËΩâ(‰∫§)ÊèõÊàñË™çË≥ºÊôÆÈÄöËÇ° |\n\n### Company Information\n\n| Table Name | Description |\n|-----------|-------------|\n| `company_basic_info` | ‰ºÅÊ•≠Âü∫Êú¨Ë≥áË®ä |\n| `company_main_business` | ‰ºÅÊ•≠‰∏ªË¶ÅÁ∂ìÁáüÊ•≠Âãô |\n| `important_subsidiary` | ‰ºÅÊ•≠ÈáçË¶ÅÂ≠êÂÖ¨Âè∏Ë≥áË®ä |\n| `security_categories` | Âè∞ËÇ°Ë≠âÂà∏ÂàÜÈ°û |\n| `security_industry_themes` | Áî¢Ê•≠È°åÊùê |\n\n**Stock ID to Name Mapping:**\n```python\n# company_basic_info ÁöÑ index ÊòØÊµÅÊ∞¥ËôüÔºåÈúÄÁî® stock_id Ê¨Ñ‰ΩçÂ∞çÊáâ\ninfo = data.get(\"company_basic_info\")\nname_map = dict(zip(info[\"stock_id\"], info[\"ÂÖ¨Âè∏Á∞°Á®±\"]))\n\n# Áî®Ê≥ï: name_map.get(\"2330\") -> \"Âè∞Á©çÈõª\"\ndf[\"ËÇ°Á•®ÂêçÁ®±\"] = df.index.map(lambda x: name_map.get(x, x))\n```\n\n### Special Status\n\n| Table Name | Description | Usage |\n|-----------|-------------|-------|\n| `etl:disposal_stock_filter` | ÊéíÈô§ËôïÁΩÆËÇ° | Boolean filter |\n| `etl:noticed_stock_filter` | ÊéíÈô§Ê≥®ÊÑèËÇ° | Boolean filter |\n| `etl:full_cash_delivery_stock_filter` | ÊéíÈô§ÂÖ®È°ç‰∫§Ââ≤ËÇ° | Boolean filter |\n| `trading_attention` | Ê≥®ÊÑèËÇ° | Status table |\n| `disposal_information` | ËôïÁΩÆËÇ° | Status table |\n| `change_transaction` | ‰∏äÂ∏ÇÊ´ÉËÆäÊõ¥‰∫§Êòì | ËÆäÊõ¥‰∫§Êòì, ÂàÜÁõ§‰∫§Êòì |\n\n### Special Dates\n\n| Table Name | Description |\n|-----------|-------------|\n| `etl:financial_statements_deadline` | Ë≤°Â†±Êà™Ê≠¢Êó• |\n| `etl:financial_statements_disclosure_dates` | Ë≤°Â†±ÈõªÂ≠êÊ™î‰∏äÂÇ≥Êó• |\n| `financial_statements_upload_detail` | Ë≤°Â†±ÈõªÂ≠êÊ™î‰∏äÂÇ≥Á¥ÄÈåÑ |\n\n---\n\n## Plotting Data\n\nUse `etl:adj_close` for historical comparison (backward adjusted, ÂêëÂæåÈÇÑÂéü).\n\n```python\nimport matplotlib.pyplot as plt\nfrom finlab import data, ffn_core\n\nadj_close = data.get('etl:adj_close')\nadj_close[['2330', '2317', '2454']].loc['2020':].rebase().plot(figsize=(12, 6))\nplt.title('ËÇ°ÂÉπËµ∞Âã¢ÊØîËºÉ')\nplt.show()\n```\n\n---\n\n## Storage Configuration\n\nControl how data is cached locally. By default, FinLab caches data to disk to avoid repeated downloads.\n\n### data.set_storage()\n\nConfigure the storage backend for data caching.\n\n**Signature:**\n```python\ndata.set_storage(storage: Storage) -> None\n```\n\n**Parameters:**\n- `storage` (Storage, required): Storage backend instance. Options:\n  - `data.FileStorage()` - Disk-based storage (default)\n  - `data.CacheStorage()` - In-memory storage (faster, but lost on restart)\n\n**Example:**\n```python\nfrom finlab import data\n\n# Use in-memory storage (faster for repeated access in same session)\ndata.set_storage(data.CacheStorage())\n\n# Use disk storage (default, persists across sessions)\ndata.set_storage(data.FileStorage())\n```\n\n### data.clear()\n\nClear all cached data from the current storage backend.\n\n**Signature:**\n```python\ndata.clear() -> None\n```\n\n**Example:**\n```python\nfrom finlab import data\n\n# Clear all cached data\ndata.clear()\n\n# Next data.get() will re-download from cloud\nclose = data.get('price:Êî∂Áõ§ÂÉπ')\n```\n\n### Configuration Flags\n\nControl data fetching behavior using module-level flags.\n\n| Flag | Type | Default | Description |\n|------|------|---------|-------------|\n| `data.use_local_data_only` | bool | False | Prevent cloud downloads; use only local cache. Raises error if data not cached. |\n| `data.force_cloud_download` | bool | False | Always download fresh data from cloud, ignoring cache. |\n| `data.prefer_local_if_exists` | bool | False | Use local cache without checking expiry. Faster startup. |\n| `data.truncate_start` | str/None | None | Filter data to start from this date (format: `'YYYY-MM-DD'`). |\n| `data.truncate_end` | str/None | None | Filter data to end at this date (format: `'YYYY-MM-DD'`). |\n\n**Examples:**\n```python\nfrom finlab import data\n\n# Offline mode - use only local cache\ndata.use_local_data_only = True\nclose = data.get('price:Êî∂Áõ§ÂÉπ')  # Fails if not cached\n\n# Force fresh download\ndata.force_cloud_download = True\nclose = data.get('price:Êî∂Áõ§ÂÉπ')  # Always downloads\n\n# Use local cache without expiry check (faster)\ndata.prefer_local_if_exists = True\nclose = data.get('price:Êî∂Áõ§ÂÉπ')\n\n# Limit data range\ndata.truncate_start = '2020-01-01'\ndata.truncate_end = '2023-12-31'\nclose = data.get('price:Êî∂Áõ§ÂÉπ')  # Only 2020-2023 data\n\n# Reset to defaults\ndata.use_local_data_only = False\ndata.force_cloud_download = False\ndata.prefer_local_if_exists = False\ndata.truncate_start = None\ndata.truncate_end = None\n```\n\n---\n\n## Related References\n\n- [FinlabDataFrame Reference](dataframe-reference.md) - Enhanced DataFrame methods for data manipulation\n- [Backtesting Reference](backtesting-reference.md) - How to use data in backtesting\n- [Factor Examples](factor-examples.md) - Practical examples using various datasets\n- [Factor Analysis Reference](factor-analysis-reference.md) - Analyze factor effectiveness\n",
  "dataframe-reference": "# FinlabDataFrame Reference\n\n## Overview\n\nFinlabDataFrame is a powerful extension of pandas DataFrame specifically designed for financial data analysis and backtesting. It provides enhanced functionality for trading strategy development, including automatic index/column alignment, moving averages, entry/exit signal detection, and industry-based ranking.\n\n## Key Features\n\n- Automatic re-alignment of indices and columns during arithmetic and logical operations\n- Built-in methods for moving averages and technical calculations\n- Entry/exit signal detection for trading strategies\n- Industry-based grouping and ranking\n- Multi-factor and industry neutralization\n- Integration with backtesting workflows\n\n**Contents:** [Constructor](#constructor) | [Index Conversion](#index-conversion-methods) | [Moving Average & Comparison](#moving-average--comparison-methods) | [Selection](#selection-methods) | [Signal Detection](#signal-detection-methods) | [Industry & Category](#industry--category-methods) | [Neutralization](#neutralization-methods) | [Quantile](#quantile-methods) | [Auto Alignment](#automatic-index-alignment) | [Method Chaining](#method-chaining-patterns)\n\n---\n\n## Constructor\n\n### FinlabDataFrame\n\nConverts a regular pandas DataFrame to a FinlabDataFrame with enhanced financial data processing capabilities.\n\n**Signature:**\n```python\nFinlabDataFrame(df: pd.DataFrame)\n```\n\n**Parameters:**\n- `df` (pd.DataFrame, required): A pandas DataFrame to be converted to FinlabDataFrame\n\n**Returns:**\n- An instance of FinlabDataFrame with enhanced financial data processing capabilities\n\n**Example:**\n```python\nfrom finlab.dataframe import FinlabDataFrame\nfrom finlab import data\nimport pandas as pd\n\n# Convert existing pandas DataFrame to FinlabDataFrame\nregular_df = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]})\ndf = FinlabDataFrame(regular_df)\n\n# FinlabDataFrame is also automatically returned by data.get()\nprice_df = data.get('price:Êî∂Áõ§ÂÉπ')  # Returns a FinlabDataFrame\n```\n\n---\n\n## Index Conversion Methods\n\n### index_str_to_date\n\nConverts string-formatted financial report indices (e.g., \"2022-Q1\", \"2022-M01\") to datetime format based on actual disclosure dates. Essential for aligning financial data with daily price data.\n\n**Signature:**\n```python\nindex_str_to_date() -> FinlabDataFrame\n```\n\n**Returns:**\n- FinlabDataFrame with datetime index based on actual disclosure dates\n\n**Example:**\n```python\nfrom finlab import data\n\n# Financial statement data has string index like \"2022-Q1\"\ncash = data.get('financial_statement:ÁèæÈáëÂèäÁ¥ÑÁï∂ÁèæÈáë')\nprint(cash.index[:3])  # ['2013-Q1', '2013-Q2', '2013-Q3']\n\n# Convert to actual disclosure dates\ncash_dated = cash.index_str_to_date()\nprint(cash_dated.index[:3])  # DatetimeIndex(['2013-05-15', '2013-08-14', ...])\n```\n\n**Note:** This method uses actual financial statement disclosure dates from `etl:financial_statements_disclosure_dates`, not simple quarter-end dates.\n\n---\n\n### deadline\n\nConverts financial report indices to regulatory deadline dates (ÂÖ¨ÂëäÊà™Ê≠¢Êó•). Unlike `index_str_to_date()` which uses actual disclosure dates, this uses the official filing deadlines.\n\n**Signature:**\n```python\ndeadline() -> FinlabDataFrame\n```\n\n**Returns:**\n- FinlabDataFrame with datetime index based on regulatory filing deadlines\n\n**Example:**\n```python\nfrom finlab import data\n\n# Convert quarterly data to deadline dates\ncash = data.get('financial_statement:ÁèæÈáëÂèäÁ¥ÑÁï∂ÁèæÈáë')\ncash_deadline = cash.deadline()\n\n# Convert monthly revenue to deadline dates\nrevenue = data.get('monthly_revenue:Áï∂ÊúàÁáüÊî∂')\nrevenue_deadline = revenue.deadline()\n```\n\n**Use Case:** Use `deadline()` when you want conservative signal timing that assumes data arrives at the latest possible date. Use `index_str_to_date()` when you want signal timing based on actual historical disclosure.\n\n---\n\n## Moving Average & Comparison Methods\n\n### average\n\nCalculates a moving average over n periods. Returns NaN if more than half the values in the window are NaN.\n\n**Signature:**\n```python\naverage(n: int) -> FinlabDataFrame\n```\n\n**Parameters:**\n- `n` (int, required): Number of periods for the moving average\n\n**Returns:**\n- FinlabDataFrame representing the moving average\n\n**Example:**\n```python\nfrom finlab import data\n\nclose = data.get('price:Êî∂Áõ§ÂÉπ')\nsma10 = close.average(10)\nsma60 = close.average(60)\n\n# Stock price above moving average\ncond = close > sma60\n```\n\n---\n\n### rise\n\nDetermines if values are rising compared to n periods before. Returns True if current value > value n periods ago.\n\n**Signature:**\n```python\nrise(n: int = 1) -> FinlabDataFrame\n```\n\n**Parameters:**\n- `n` (int, optional, default=1): Number of periods to compare\n\n**Returns:**\n- Boolean FinlabDataFrame indicating rising trends\n\n**Example:**\n```python\nfrom finlab import data\n\nclose = data.get('price:Êî∂Áõ§ÂÉπ')\n\n# Price higher than 10 days ago\nrising = close.rise(10)\n\n# Consecutive rising days\nconsecutive_rise = close.rise().sustain(3)\n```\n\n---\n\n### fall\n\nDetermines if values are falling compared to n periods before. Returns True if current value < value n periods ago.\n\n**Signature:**\n```python\nfall(n: int = 1) -> FinlabDataFrame\n```\n\n**Parameters:**\n- `n` (int, optional, default=1): Number of periods to compare\n\n**Returns:**\n- Boolean FinlabDataFrame indicating falling trends\n\n**Example:**\n```python\nfrom finlab import data\n\nclose = data.get('price:Êî∂Áõ§ÂÉπ')\n\n# Price lower than 10 days ago\nfalling = close.fall(10)\n\n# Avoid stocks in downtrend\navoid = close.fall(20)\n```\n\n---\n\n### sustain\n\nChecks whether a condition is sustained over a moving window of n days. Returns True if the sum of True values in the window meets or exceeds the threshold.\n\n**Signature:**\n```python\nsustain(nwindow: int, nsatisfy: int = None) -> FinlabDataFrame\n```\n\n**Parameters:**\n- `nwindow` (int, required): Window length (in days)\n- `nsatisfy` (int, optional): Minimum number of True values required; defaults to `nwindow` if not provided\n\n**Returns:**\n- Boolean FinlabDataFrame\n\n**Example:**\n```python\nfrom finlab import data\n\nclose = data.get('price:Êî∂Áõ§ÂÉπ')\n\n# Price rising for 3 consecutive days\nrising_3days = close.rise().sustain(3)\n\n# Price rising at least 4 out of 5 days\nrising_4of5 = close.rise().sustain(5, 4)\n```\n\n---\n\n## Selection Methods\n\n### is_largest\n\nReturns a boolean DataFrame where True values represent the top n largest values for each date. Eliminates the need for row-by-row iteration with nlargest.\n\n**Signature:**\n```python\nis_largest(n: int) -> FinlabDataFrame\n```\n\n**Parameters:**\n- `n` (int, required): Number of top values to select on each date\n\n**Returns:**\n- Boolean FinlabDataFrame with True for top n stocks on each date\n\n**Example:**\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\n# Select 10 stocks with highest ROA\nroa = data.get('fundamental_features:ROAÁ®ÖÂæåÊÅØÂâç')\ntop_roa = roa.is_largest(10)\n\n# Backtest holding top ROA stocks\nreport = sim(top_roa, resample='Q')\n```\n\n---\n\n### is_smallest\n\nReturns a boolean DataFrame where True values represent the n smallest values for each date.\n\n**Signature:**\n```python\nis_smallest(n: int) -> FinlabDataFrame\n```\n\n**Parameters:**\n- `n` (int, required): Number of smallest values to select on each date\n\n**Returns:**\n- Boolean FinlabDataFrame with True for bottom n stocks on each date\n\n**Example:**\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\n# Select 10 stocks with lowest P/B ratio\npb = data.get('price_earning_ratio:ËÇ°ÂÉπÊ∑®ÂÄºÊØî')\nlowest_pb = pb.is_smallest(10)\n\n# Backtest value strategy\nreport = sim(lowest_pb, resample='M')\n```\n\n---\n\n### rank\n\nComputes ranking across rows or columns. **Includes lookahead bias warning when ranking along the time axis.**\n\n**Signature:**\n```python\nrank(*args, valid=None, **kwargs) -> FinlabDataFrame\n```\n\n**Parameters:**\n- Same parameters as `pandas.DataFrame.rank()`\n- `axis` (int or str, default=0): Axis to rank along. **Warning: axis=0 may cause lookahead bias**\n- `valid` (DataFrame or Series of bool, optional): Only cells where `valid` is True participate in ranking. Cells where `valid` is False/NaN are set to NaN before ranking, so they do not affect the `pct=True` denominator. Common usage: after `fillna()`, pass the original `notna()` mask to prevent newly-listed or history-insufficient stocks from polluting percentile rankings.\n\n**Returns:**\n- FinlabDataFrame with rankings\n\n**Example:**\n```python\nfrom finlab import data\n\npb = data.get('price_earning_ratio:ËÇ°ÂÉπÊ∑®ÂÄºÊØî')\n\n# SAFE: Cross-sectional ranking (rank stocks against each other per day)\npb_rank = pb.rank(axis=1, pct=True)\n\n# Select stocks in bottom 30% of P/B each day\ncheap = pb_rank < 0.3\n\n# Using valid= to exclude fillna'd stocks from rank denominator:\nclose = data.get('price:Êî∂Áõ§ÂÉπ')\nratio = close / close.shift(5)\n# fillna(1) is needed for SLOPE computation, but those fake values\n# should not count in percentile ranking\nscore = ratio.fillna(1).apply(some_func)\nscore.rank(axis=1, pct=True, valid=ratio.notna())\n\n# WARNING: Time-series ranking triggers LookaheadWarning\n# This ranks each stock's current value against its future values\n# pb.rank(axis=0)  # Will emit warning - use rolling().rank() instead\n```\n\n**Warning:** Ranking along `axis=0` (time axis) uses future data and will emit a `LookaheadWarning`. Use `rolling().rank()` or `expanding().rank()` for safe time-series ranking.\n\n---\n\n## Signal Detection Methods\n\n### is_entry\n\nIdentifies entry signal points where the condition switches from False to True.\n\n**Signature:**\n```python\nis_entry() -> FinlabDataFrame\n```\n\n**Returns:**\n- Boolean FinlabDataFrame indicating entry signals\n\n**Example:**\n```python\nfrom finlab import data\n\nclose = data.get('price:Êî∂Áõ§ÂÉπ')\n\n# Condition: price in top 10\nposition = close.is_largest(10)\n\n# Find days when stock enters top 10\nentry_signals = position.is_entry()\n```\n\n---\n\n### is_exit\n\nIdentifies exit signal points where the condition switches from True to False.\n\n**Signature:**\n```python\nis_exit() -> FinlabDataFrame\n```\n\n**Returns:**\n- Boolean FinlabDataFrame indicating exit signals\n\n**Example:**\n```python\nfrom finlab import data\n\nclose = data.get('price:Êî∂Áõ§ÂÉπ')\n\n# Condition: price in top 10\nposition = close.is_largest(10)\n\n# Find days when stock exits top 10\nexit_signals = position.is_exit()\n```\n\n---\n\n### exit_when\n\nCreates a position DataFrame that enters on entry signals and exits when either the original condition becomes False OR the specified exit condition becomes True.\n\n**Signature:**\n```python\nexit_when(exit: pd.DataFrame) -> FinlabDataFrame\n```\n\n**Parameters:**\n- `exit` (pd.DataFrame, required): Additional exit condition DataFrame\n\n**Returns:**\n- Boolean FinlabDataFrame representing positions\n\n**Example:**\n```python\nfrom finlab import data\n\nclose = data.get('price:Êî∂Áõ§ÂÉπ')\nvolume = data.get('price:Êàê‰∫§ËÇ°Êï∏')\n\n# Entry: price breaks above 20-day high\nentry_cond = close > close.rolling(20).max().shift()\n\n# Additional exit: volume spike (possible distribution)\nvolume_spike = volume > volume.average(20) * 3\n\n# Position with additional exit condition\nposition = entry_cond.exit_when(volume_spike)\n```\n\n---\n\n### hold_until\n\nGenerates trading positions based on entry signals until exit signals occur. Supports stock rotation limits, stop-loss/take-profit, and ranking-based selection.\n\n**Signature:**\n```python\nhold_until(\n    exit: pd.DataFrame,\n    nstocks_limit: int = None,\n    stop_loss: float = -np.inf,\n    take_profit: float = np.inf,\n    trade_at: str = 'close',\n    rank: pd.DataFrame = None\n) -> FinlabDataFrame\n```\n\n**Parameters:**\n- `exit` (pd.DataFrame, required): Exit signal DataFrame\n- `nstocks_limit` (int, optional): Maximum number of stocks to hold simultaneously\n- `stop_loss` (float, optional, default=-np.inf): Stop loss threshold (e.g., 0.1 = exit if down 10%)\n- `take_profit` (float, optional, default=np.inf): Take profit threshold (e.g., 0.2 = exit if up 20%)\n- `trade_at` (str, optional, default='close'): Price reference for stop/take profit ('close' or 'open')\n- `rank` (pd.DataFrame, optional): Ranking DataFrame for prioritizing entries when limit is reached (higher = priority)\n\n**Returns:**\n- Boolean FinlabDataFrame with positions (True indicates holding)\n\n**Example:**\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\nclose = data.get('price:Êî∂Áõ§ÂÉπ')\npb = data.get('price_earning_ratio:ËÇ°ÂÉπÊ∑®ÂÄºÊØî')\n\n# Entry: price above 20-day MA\nentries = close > close.average(20)\n\n# Exit: price below 60-day MA\nexits = close < close.average(60)\n\n# Hold max 10 stocks, prefer lower P/B (use negative for ascending)\nposition = entries.hold_until(\n    exits,\n    nstocks_limit=10,\n    stop_loss=0.1,      # 10% stop loss\n    take_profit=0.3,    # 30% take profit\n    rank=-pb            # Lower P/B = higher priority\n)\n\nreport = sim(position)\n```\n\n---\n\n## Industry & Category Methods\n\n### groupby_category\n\nGroups DataFrame columns by their industry category. Similar to `pandas.DataFrame.groupby()` but groups stocks by industry.\n\n**Signature:**\n```python\ngroupby_category() -> pd.core.groupby.DataFrameGroupBy\n```\n\n**Returns:**\n- A GroupBy object with groups defined by industry categories\n\n**Example:**\n```python\nfrom finlab import data\n\npb = data.get('price_earning_ratio:ËÇ°ÂÉπÊ∑®ÂÄºÊØî')\n\n# Average P/B by industry\nindustry_pb = pb.groupby_category().mean()\n\n# Plot semiconductor industry P/B over time\nindustry_pb['ÂçäÂ∞éÈ´î'].plot(title='Semiconductor P/B Ratio')\n```\n\n---\n\n### industry_rank\n\nCalculates percentile ranking for stocks within their respective industries. Returns values from 0 (lowest in industry) to 1 (highest in industry).\n\n**Signature:**\n```python\nindustry_rank(categories: list = None) -> FinlabDataFrame\n```\n\n**Parameters:**\n- `categories` (list, optional): List of industry categories to consider. If None, uses all industries from `data.get('security_industry_themes')`\n\n**Returns:**\n- FinlabDataFrame with industry-relative ranking scores (0 to 1)\n\n**Example:**\n```python\nfrom finlab import data\n\npe = data.get('price_earning_ratio:Êú¨ÁõäÊØî')\n\n# Rank P/E within each industry\npe_industry_rank = pe.industry_rank()\n\n# Select stocks that are cheap relative to their industry\ncheap_in_industry = pe_industry_rank < 0.3\n```\n\n---\n\n### entry_price\n\nRetrieves the adjusted price at entry signal points.\n\n**Signature:**\n```python\nentry_price(trade_at: str = 'close') -> FinlabDataFrame\n```\n\n**Parameters:**\n- `trade_at` (str, optional, default='close'): Price type ('close' or 'open')\n\n**Returns:**\n- FinlabDataFrame with entry prices (forward-filled)\n\n**Example:**\n```python\nfrom finlab import data\n\nclose = data.get('price:Êî∂Áõ§ÂÉπ')\n\n# Position signal\nposition = close.is_largest(10)\n\n# Get entry prices for calculating returns\nentry_prices = position.entry_price()\ncurrent_return = close / entry_prices - 1\n```\n\n---\n\n## Neutralization Methods\n\n### neutralize\n\nPerforms cross-sectional regression to neutralize factors from the data. Returns residuals after regressing on specified neutralizer factors.\n\n**Signature:**\n```python\nneutralize(\n    neutralizers: Union[pd.DataFrame, list[pd.DataFrame], dict[str, pd.DataFrame]],\n    add_const: bool = True\n) -> FinlabDataFrame\n```\n\n**Parameters:**\n- `neutralizers` (DataFrame, list, or dict, required): Factor(s) to neutralize against\n  - Single DataFrame: neutralize against one factor\n  - List of DataFrames: neutralize against multiple factors\n  - Dict of DataFrames: neutralize with named factors\n- `add_const` (bool, optional, default=True): Whether to include intercept in regression\n\n**Returns:**\n- FinlabDataFrame containing regression residuals (neutralized values)\n\n**Example:**\n```python\nfrom finlab import data\n\n# Original factor\npe = data.get('price_earning_ratio:Êú¨ÁõäÊØî')\n\n# Neutralize against size (market cap)\nsize = data.get('etl:market_value')\npe_size_neutral = pe.neutralize(size)\n\n# Neutralize against multiple factors\npb = data.get('price_earning_ratio:ËÇ°ÂÉπÊ∑®ÂÄºÊØî')\npe_multi_neutral = pe.neutralize([size, pb])\n\n# Neutralize with named factors (for clarity)\npe_named_neutral = pe.neutralize({\n    'size': size,\n    'size_squared': size ** 2,\n    'pb': pb\n})\n```\n\n**Use Case:** Factor neutralization removes unwanted exposures. For example, if you want a value factor that isn't just picking small-cap stocks, neutralize against market cap.\n\n---\n\n### neutralize_industry\n\nPerforms cross-sectional regression to neutralize industry effects. Each stock is regressed on industry dummy variables, returning industry-neutral residuals.\n\n**Signature:**\n```python\nneutralize_industry(\n    categories: pd.DataFrame = None,\n    add_const: bool = True\n) -> FinlabDataFrame\n```\n\n**Parameters:**\n- `categories` (pd.DataFrame, optional): DataFrame with 'stock_id' and 'category' columns. If None, uses `data.get('security_categories')`\n- `add_const` (bool, optional, default=True): Whether to include intercept (one dummy is dropped to avoid multicollinearity)\n\n**Returns:**\n- FinlabDataFrame containing industry-neutralized values\n\n**Example:**\n```python\nfrom finlab import data\n\n# P/E ratio varies significantly by industry\npe = data.get('price_earning_ratio:Êú¨ÁõäÊØî')\n\n# Remove industry effects\npe_industry_neutral = pe.neutralize_industry()\n\n# Now pe_industry_neutral represents deviation from industry average\n# Positive = expensive relative to industry peers\n# Negative = cheap relative to industry peers\n\n# Custom industry categories\ncustom_cats = pd.DataFrame({\n    'stock_id': ['2330', '2317', '1101', '2412'],\n    'category': ['ÂçäÂ∞éÈ´î', 'ÈõªÂ≠ê', 'Ê∞¥Ê≥•', 'Èõª‰ø°']\n})\npe_custom_neutral = pe.neutralize_industry(categories=custom_cats)\n```\n\n---\n\n## Quantile Methods\n\n### quantile_row\n\nComputes the specified quantile across all stocks for each date.\n\n**Signature:**\n```python\nquantile_row(c: float) -> pd.Series\n```\n\n**Parameters:**\n- `c` (float, required): Quantile value between 0 and 1 (e.g., 0.9 for 90th percentile)\n\n**Returns:**\n- pandas Series containing the quantile value per date\n\n**Example:**\n```python\nfrom finlab import data\n\nclose = data.get('price:Êî∂Áõ§ÂÉπ')\n\n# 90th percentile price each day\nq90 = close.quantile_row(0.9)\n\n# Median price each day\nmedian = close.quantile_row(0.5)\n\n# Select stocks above 90th percentile\nexpensive = close > close.quantile_row(0.9)\n```\n\n---\n\n## Automatic Index Alignment\n\nFinlabDataFrame automatically aligns indices and columns when performing operations between DataFrames with different frequencies or shapes.\n\n**Supported Operations:**\n- Arithmetic: `+`, `-`, `*`, `/`, `//`, `%`, `**`\n- Comparison: `>`, `>=`, `==`, `!=`, `<`, `<=`\n- Logical: `&`, `|`, `^`\n\n**Example:**\n```python\nfrom finlab import data\n\n# Daily data\nclose = data.get('price:Êî∂Áõ§ÂÉπ')  # Daily frequency\n\n# Quarterly data\nroa = data.get('fundamental_features:ROAÁ®ÖÂæåÊÅØÂâç')  # Quarterly frequency\n\n# Operations automatically align - no manual reindex needed\ncond1 = close > close.average(60)  # Daily condition\ncond2 = roa > 0                     # Quarterly condition\n\n# Intersection works across frequencies\n# Quarterly data is forward-filled to daily\nposition = cond1 & cond2\n```\n\n**Alignment Rules:**\n1. Index: Union of both indices, forward-filled\n2. Columns: Intersection of both column sets\n3. String indices (e.g., \"2022-Q1\") are converted to datetime using disclosure dates\n\n---\n\n## Method Chaining Patterns\n\nFinlabDataFrame methods can be chained for concise strategy expression.\n\n**Example: Complete Strategy**\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\nclose = data.get('price:Êî∂Áõ§ÂÉπ')\npb = data.get('price_earning_ratio:ËÇ°ÂÉπÊ∑®ÂÄºÊØî')\nroa = data.get('fundamental_features:ROAÁ®ÖÂæåÊÅØÂâç')\n\n# Chain conditions and selection\nposition = (\n    pb[\n        (close > close.average(60)) &     # Above 60-day MA\n        (roa > 0) &                        # Profitable\n        (close.rise(5))                    # Rising momentum\n    ]\n    .neutralize_industry()                 # Industry-neutral P/B\n    .is_smallest(10)                       # Cheapest 10 stocks\n)\n\nreport = sim(position, resample='M')\n```\n\n---\n\n## Related References\n\n- [Backtesting Reference](backtesting-reference.md) - Learn how to backtest strategies using FinlabDataFrame\n- [Data Reference](data-reference.md) - Explore available data sources\n- [Factor Examples](factor-examples.md) - See practical examples of using FinlabDataFrame in strategies\n- [Best Practices](best-practices.md) - Avoid common pitfalls including lookahead bias\n",
  "factor-analysis-reference": "# Factor Analysis Reference\n\n## Overview\n\nThe FinLab factor analysis module provides comprehensive tools for evaluating factor effectiveness, calculating Information Coefficient (IC), analyzing factor trends, and computing factor contributions using Shapley values. These tools help you understand which factors drive returns and how to construct better trading strategies.\n\n**Import:**\n```python\nfrom finlab.tools.factor_analysis import (\n    generate_features_and_labels,\n    calc_factor_return,\n    calc_ic,\n    ic,\n    calc_metric,\n    calc_shapley_values,\n    calc_centrality,\n    calc_regression_stats\n)\n```\n\n**Contents:** [Quick Start](#quick-start) | [Functions](#functions) | [Advanced Examples](#advanced-analysis-examples) | [Best Practices](#best-practices)\n\n---\n\n## Quick Start\n\n### Basic Factor Analysis Workflow\n\n```python\nfrom finlab import data\nfrom finlab.tools.factor_analysis import generate_features_and_labels, calc_factor_return, calc_ic\n\n# Get data\nprice = data.get('etl:adj_close')\nmarketcap = data.get('etl:market_value')\nrevenue = data.get('monthly_revenue:Áï∂ÊúàÁáüÊî∂')\n\n# Generate features and labels\nfeatures, labels = generate_features_and_labels({\n    'marketcap': marketcap.rank(pct=True, axis=1) < 0.3,\n    'revenue': (revenue.average(3) / revenue.average(12)).rank(pct=True, axis=1) < 0.3,\n    'momentum': price / price.shift(20) - 1 > 0,\n}, resample=revenue.index)\n\n# Calculate factor returns\nfactor_return = calc_factor_return(features, labels)\nprint(factor_return.head())\n\n# Calculate IC (Information Coefficient)\nic_df = calc_ic(features, labels, rank=True)\nprint(ic_df.mean())\n```\n\n---\n\n## Functions\n\n### generate_features_and_labels\n\nGenerate factor features and labels: combines factors into a feature DataFrame and generates excess return labels.\n\n**Signature:**\n```python\ngenerate_features_and_labels(\n    dfs: Dict[str, Union[pd.DataFrame, Callable]],\n    resample: str\n) -> tuple[pd.DataFrame, pd.Series]\n```\n\n**Parameters:**\n- `dfs` (dict, required): Factor dictionary where keys are factor names and values are DataFrame or callable functions that return DataFrame (standard input for feature.combine)\n- `resample` (str, required): Resampling frequency string (e.g., 'M', 'Q', 'Y'), used for feature and label generation\n\n**Returns:**\n- `tuple[pd.DataFrame, pd.Series]`: (features, labels). features has date index with columns as factor names; labels are excess returns with the same index\n\n**Example:**\n```python\nfrom finlab import data\nfrom finlab.tools.factor_analysis import generate_features_and_labels\n\nprice = data.get('etl:adj_close')\nmarketcap = data.get('etl:market_value')\nrevenue = data.get('monthly_revenue:Áï∂ÊúàÁáüÊî∂')\n\nfeatures, labels = generate_features_and_labels({\n    'marketcap': marketcap.rank(pct=True, axis=1) < 0.3,\n    'revenue': (revenue.average(3) / revenue.average(12)).rank(pct=True, axis=1) < 0.3,\n    'momentum': price / price.shift(20) - 1 > 0,\n}, resample=revenue.index)\n\nprint(f'Features shape: {features.shape}')\nprint(f'Labels shape: {labels.shape}')\n```\n\n---\n\n### calc_factor_return\n\nCalculate equal-weight portfolio returns based on features and labels. Automatically validates features as boolean values, calculates equal-weight portfolio returns per factor, and outputs starting from the first non-empty row.\n\n**Signature:**\n```python\ncalc_factor_return(\n    features: pd.DataFrame,\n    labels: pd.Series\n) -> pd.DataFrame\n```\n\n**Parameters:**\n- `features` (pd.DataFrame, required): Feature DataFrame with date index, factor names as columns, and boolean values\n- `labels` (pd.Series, required): Label Series with date index and excess returns as values\n\n**Returns:**\n- `pd.DataFrame`: Equal-weight portfolio period returns indexed by date with factor names as columns, starting from the first non-empty row\n\n**Example:**\n```python\nfrom finlab import data\nfrom finlab.tools.factor_analysis import calc_factor_return, generate_features_and_labels\n\nprice = data.get('etl:adj_close')\nmarketcap = data.get('etl:market_value')\nrevenue = data.get('monthly_revenue:Áï∂ÊúàÁáüÊî∂')\n\n# Generate features and labels\nfeatures, labels = generate_features_and_labels({\n    'marketcap': marketcap.rank(pct=True, axis=1) < 0.3,\n    'revenue': (revenue.average(3) / revenue.average(12)).rank(pct=True, axis=1) < 0.3,\n    'momentum': price / price.shift(20) - 1 > 0,\n}, resample=revenue.index)\n\n# Calculate factor returns\nfactor_return = calc_factor_return(features, labels)\nprint(factor_return.head())\n\n# Analyze cumulative returns\ncumulative_return = (1 + factor_return).cumprod()\ncumulative_return.plot(figsize=(12, 6))\n```\n\n---\n\n### calc_ic\n\nCalculate the correlation coefficient (IC) between features and labels. Optionally rank features first for Rank IC. Outputs starting from the first non-empty row.\n\n**Signature:**\n```python\ncalc_ic(\n    features: pd.DataFrame,\n    labels: pd.Series,\n    rank: bool = False\n) -> pd.DataFrame\n```\n\n**Parameters:**\n- `features` (pd.DataFrame, required): Feature DataFrame with MultiIndex (date, stock_id) and factor names as columns\n- `labels` (pd.Series, required): Label Series with MultiIndex (date, stock_id)\n- `rank` (bool, optional, default=False): Whether to rank features first for calculating Rank IC\n\n**Returns:**\n- `pd.DataFrame`: IC values for each date and factor, starting from the first non-empty row\n\n**Example:**\n```python\nfrom finlab import data\nfrom finlab.tools.factor_analysis import calc_ic, generate_features_and_labels\n\nprice = data.get('etl:adj_close')\nmarketcap = data.get('etl:market_value')\nrevenue = data.get('monthly_revenue:Áï∂ÊúàÁáüÊî∂')\n\n# Generate features and labels (MultiIndex: date, stock_id)\nfeatures, labels = generate_features_and_labels({\n    'marketcap': marketcap.rank(pct=True, axis=1) < 0.3,\n    'revenue': (revenue.average(3) / revenue.average(12)).rank(pct=True, axis=1) < 0.3,\n    'momentum': price / price.shift(20) - 1 > 0,\n}, resample=revenue.index)\n\n# Calculate Rank IC\nic_df = calc_ic(features, labels, rank=True)\nprint(ic_df.head())\n\n# Analyze IC statistics\nprint(ic_df.mean())  # Mean IC\nprint(ic_df.std())   # IC volatility\nprint(ic_df.mean() / ic_df.std())  # IC IR (Information Ratio)\n```\n\n---\n\n### ic\n\nCalculate Information Coefficient (IC) for factors. Internally calls calc_metric with cross-sectional correlation as the evaluation function.\n\n**Signature:**\n```python\nic(\n    factor: pd.DataFrame | Dict[str, pd.DataFrame],\n    adj_close: pd.DataFrame,\n    days: list[int] = [10, 20, 60, 120]\n) -> pd.DataFrame\n```\n\n**Parameters:**\n- `factor` (pd.DataFrame or dict, required): Factor data as DataFrame (columns are stock IDs) or dict[str, DataFrame] (keys are factor names)\n- `adj_close` (pd.DataFrame, required): Adjusted closing price DataFrame (columns are stock IDs) for calculating future returns\n- `days` (list[int], optional, default=[10, 20, 60, 120]): Prediction horizon list for calculating d-day future returns\n\n**Returns:**\n- `pd.DataFrame`: IC for each factor at different prediction horizons. Column names are <factor>_<days>, indexed by date\n\n**Example:**\n```python\nfrom finlab import data\nfrom finlab.tools.factor_analysis import ic\n\n# Build factor and price\nfactor = data.indicator('RSI')\nadj_close = data.get('etl:adj_close')\n\n# Calculate IC (correlation coefficient)\nic_df = ic(factor, adj_close)\nprint(ic_df.head())\n\n# Analyze IC at different horizons\nprint(ic_df.mean())\nic_df.plot(figsize=(12, 6))\n```\n\n---\n\n### calc_metric\n\nCalculate evaluation metrics for factors and future returns at multiple prediction horizons. Supports single DataFrame or mapping of factor names to DataFrames. Automatically aligns and trims time series.\n\n**Signature:**\n```python\ncalc_metric(\n    factor: pd.DataFrame | Dict[str, pd.DataFrame],\n    adj_close: pd.DataFrame,\n    days: list[int] = [10, 20, 60, 120],\n    func = corr\n) -> pd.DataFrame\n```\n\n**Parameters:**\n- `factor` (pd.DataFrame or dict, required): Factor data as DataFrame (columns are stock IDs) or dict[str, DataFrame] (keys are factor names)\n- `adj_close` (pd.DataFrame, required): Adjusted closing price DataFrame (columns are stock IDs) for calculating future returns\n- `days` (list[int], optional, default=[10, 20, 60, 120]): Prediction horizon list for calculating d-day future returns\n- `func` (callable, optional): Aggregation function for each date group. Takes DataFrame with 'ret' and 'f' columns and returns a single statistic. Default is corr (correlation coefficient)\n\n**Returns:**\n- `pd.DataFrame`: Evaluation results for each factor at different prediction horizons. Column names are <factor>_<days>, indexed by date\n\n**Example:**\n```python\nfrom finlab import data\nfrom finlab.tools.factor_analysis import calc_metric\n\n# Build factor and price\nfactor = data.indicator('RSI')\nadj_close = data.get('etl:adj_close')\n\n# Calculate evaluation metric (default: correlation coefficient)\nmetric_df = calc_metric(factor, adj_close)\nprint(metric_df.head())\n\n# Use custom metric function\ndef custom_metric(df):\n    # Calculate Spearman correlation\n    return df['f'].corr(df['ret'], method='spearman')\n\nmetric_df = calc_metric(factor, adj_close, func=custom_metric)\n```\n\n---\n\n### calc_shapley_values\n\nCalculate Shapley values for each factor to measure marginal contribution to portfolio performance using cooperative game theory. Enumerates all factor subsets and averages marginal contributions. Computational complexity is O(2^n) where n is the number of factors.\n\n**Signature:**\n```python\ncalc_shapley_values(\n    features: pd.DataFrame,\n    labels: pd.Series\n) -> pd.DataFrame\n```\n\n**Parameters:**\n- `features` (pd.DataFrame, required): Feature DataFrame with date index, factor names as columns, and boolean values (True indicates selected)\n- `labels` (pd.Series, required): Label Series with MultiIndex ('datetime', 'stock_id') and excess returns as values\n\n**Returns:**\n- `pd.DataFrame`: Daily Shapley values for each factor. Indexed by date with factor names as columns\n\n**Example:**\n```python\nfrom finlab import data\nfrom finlab.tools.factor_analysis import calc_shapley_values, generate_features_and_labels\n\nprice = data.get('etl:adj_close')\nmarketcap = data.get('etl:market_value')\nrevenue = data.get('monthly_revenue:Áï∂ÊúàÁáüÊî∂')\n\n# Generate features and labels\nfeatures, labels = generate_features_and_labels({\n    'marketcap': marketcap.rank(pct=True, axis=1) < 0.3,\n    'revenue': (revenue.average(3) / revenue.average(12)).rank(pct=True, axis=1) < 0.3,\n    'momentum': price / price.shift(20) - 1 > 0,\n}, resample=revenue.index)\n\n# Calculate Shapley values\nshapley_df = calc_shapley_values(features, labels)\nprint(shapley_df.head())\n\n# Analyze average contribution\nprint(shapley_df.mean())\nshapley_df.plot(figsize=(12, 6))\n```\n\n**Note:** Due to computational complexity, this function is best used with a small number of factors (typically < 10).\n\n---\n\n### calc_centrality\n\nCalculate rolling asset centrality for time series data. This is a generic function applicable to any DataFrame with time index and asset columns (e.g., factor returns). It is frequency-agnostic with rolling window specified by integer window_periods.\n\n**Signature:**\n```python\ncalc_centrality(\n    return_df: pd.DataFrame,\n    window_periods: int,\n    n_components: int = 1\n) -> pd.DataFrame\n```\n\n**Parameters:**\n- `return_df` (pd.DataFrame, required): Time series DataFrame indexed by date with assets (e.g., factor names) as columns. Despite the name return_df, it can be any asset time series\n- `window_periods` (int, required): Rolling window length in number of data points. For monthly data, 3 means 3 months\n- `n_components` (int, optional, default=1): Number of principal components for PCA calculation\n\n**Returns:**\n- `pd.DataFrame`: DataFrame with rolling centrality scores. Indexed by date (window end date) with assets as columns\n\n**Example:**\n```python\nimport pandas as pd\nfrom finlab.tools.factor_analysis import calc_centrality\n\n# Assume we have factor return time series data\ndata = {\n    'FactorA': [0.1, 0.2, 0.15, 0.12, 0.11],\n    'FactorB': [0.05, 0.04, 0.06, 0.07, 0.08],\n}\nindex = pd.to_datetime(['2025-01-01','2025-01-02','2025-01-03','2025-01-04','2025-01-05'])\nreturn_df = pd.DataFrame(data, index=index)\n\ncentrality_df = calc_centrality(return_df, window_periods=3, n_components=1)\nprint(centrality_df.head())\n```\n\n---\n\n### calc_regression_stats\n\nPerform linear regression on each time series in a DataFrame and return statistics (slope, p-value, R¬≤, tail estimate, and trend classification). Uses vectorized implementation without SciPy dependency.\n\n**Signature:**\n```python\ncalc_regression_stats(\n    df: pd.DataFrame,\n    p_value_threshold: float = 0.05,\n    r_squared_threshold: float = 0.1\n) -> pd.DataFrame\n```\n\n**Parameters:**\n- `df` (pd.DataFrame, required): Time series DataFrame indexed by DatetimeIndex with different metrics as columns\n- `p_value_threshold` (float, optional, default=0.05): P-value threshold for trend significance\n- `r_squared_threshold` (float, optional, default=0.1): R¬≤ threshold for trend explanatory power\n\n**Returns:**\n- `pd.DataFrame`: Regression statistics for each column including slope, p_value, r_squared, tail_estimate, and trend\n\n**Example:**\n```python\n# Assume ic_df is a time series of factor IC\nfrom finlab.tools.factor_analysis import calc_regression_stats\n\ntrend_stats = calc_regression_stats(ic_df)\nprint(trend_stats.head())\n\n# Filter for statistically significant upward trends\nsignificant_up = trend_stats[(trend_stats['p_value'] < 0.05) & (trend_stats['slope'] > 0)]\nprint(significant_up)\n```\n\n---\n\n## Advanced Analysis Examples\n\n### Complete Factor Analysis Pipeline\n\n```python\nfrom finlab import data\nfrom finlab.tools.factor_analysis import (\n    generate_features_and_labels,\n    calc_factor_return,\n    calc_ic,\n    calc_regression_stats,\n    calc_shapley_values\n)\nimport matplotlib.pyplot as plt\n\n# 1. Define factors\nprice = data.get('etl:adj_close')\nmarketcap = data.get('etl:market_value')\nrevenue = data.get('monthly_revenue:Áï∂ÊúàÁáüÊî∂')\npb = data.get('price_earning_ratio:ËÇ°ÂÉπÊ∑®ÂÄºÊØî')\n\n# 2. Generate features and labels\nfeatures, labels = generate_features_and_labels({\n    'small_cap': marketcap.rank(pct=True, axis=1) < 0.3,\n    'revenue_growth': (revenue.average(3) / revenue.average(12)).rank(pct=True, axis=1) < 0.3,\n    'momentum': price / price.shift(20) - 1 > 0,\n    'low_pb': pb.rank(pct=True, axis=1) < 0.3,\n}, resample='M')\n\n# 3. Calculate factor returns\nfactor_return = calc_factor_return(features, labels)\ncumulative_return = (1 + factor_return).cumprod()\n\n# 4. Calculate IC\nic_df = calc_ic(features, labels, rank=True)\nprint(\"Average IC:\")\nprint(ic_df.mean())\n\n# 5. Analyze IC trends\nic_trends = calc_regression_stats(ic_df)\nprint(\"\\nIC Trend Statistics:\")\nprint(ic_trends)\n\n# 6. Calculate Shapley values (factor contributions)\nshapley_df = calc_shapley_values(features, labels)\nprint(\"\\nAverage Shapley Values:\")\nprint(shapley_df.mean())\n\n# 7. Visualization\nfig, axes = plt.subplots(3, 1, figsize=(14, 12))\n\n# Plot cumulative returns\ncumulative_return.plot(ax=axes[0])\naxes[0].set_title('Cumulative Factor Returns')\naxes[0].set_ylabel('Cumulative Return')\naxes[0].grid(True)\n\n# Plot IC over time\nic_df.plot(ax=axes[1])\naxes[1].set_title('Information Coefficient (IC) Over Time')\naxes[1].set_ylabel('IC')\naxes[1].axhline(y=0, color='r', linestyle='--', alpha=0.3)\naxes[1].grid(True)\n\n# Plot Shapley values\nshapley_df.plot(ax=axes[2])\naxes[2].set_title('Shapley Values (Factor Contributions)')\naxes[2].set_ylabel('Shapley Value')\naxes[2].grid(True)\n\nplt.tight_layout()\nplt.show()\n```\n\n---\n\n### Multi-Horizon IC Analysis\n\n```python\nfrom finlab import data\nfrom finlab.tools.factor_analysis import ic\nimport matplotlib.pyplot as plt\n\n# Calculate factor\nrsi = data.indicator('RSI')\nadj_close = data.get('etl:adj_close')\n\n# Calculate IC at multiple horizons\nic_df = ic(rsi, adj_close, days=[5, 10, 20, 40, 60, 120])\n\n# Analyze IC statistics\nprint(\"IC Mean:\")\nprint(ic_df.mean())\nprint(\"\\nIC Std:\")\nprint(ic_df.std())\nprint(\"\\nIC IR (Mean/Std):\")\nprint(ic_df.mean() / ic_df.std())\n\n# Visualization\nfig, axes = plt.subplots(2, 1, figsize=(14, 10))\n\n# IC time series\nic_df.plot(ax=axes[0])\naxes[0].set_title('IC Across Different Horizons')\naxes[0].set_ylabel('IC')\naxes[0].axhline(y=0, color='r', linestyle='--', alpha=0.3)\naxes[0].grid(True)\n\n# IC distribution\nic_df.plot(kind='box', ax=axes[1])\naxes[1].set_title('IC Distribution Across Horizons')\naxes[1].set_ylabel('IC')\naxes[1].grid(True)\n\nplt.tight_layout()\nplt.show()\n```\n\n---\n\n### Factor Combination Analysis\n\n```python\nfrom finlab import data\nfrom finlab.tools.factor_analysis import (\n    generate_features_and_labels,\n    calc_factor_return\n)\nimport pandas as pd\n\n# Define multiple factors\nprice = data.get('etl:adj_close')\nmarketcap = data.get('etl:market_value')\nrevenue = data.get('monthly_revenue:Áï∂ÊúàÁáüÊî∂')\n\n# Generate individual features\nindividual_features, labels = generate_features_and_labels({\n    'small_cap': marketcap.rank(pct=True, axis=1) < 0.3,\n    'revenue_growth': (revenue.average(3) / revenue.average(12)).rank(pct=True, axis=1) < 0.3,\n    'momentum': price / price.shift(20) - 1 > 0,\n}, resample='M')\n\n# Create combined features\ncombined_features = pd.DataFrame(index=individual_features.index)\ncombined_features['small_cap'] = individual_features['small_cap']\ncombined_features['revenue_growth'] = individual_features['revenue_growth']\ncombined_features['momentum'] = individual_features['momentum']\ncombined_features['small_cap+revenue'] = individual_features['small_cap'] & individual_features['revenue_growth']\ncombined_features['all_three'] = individual_features['small_cap'] & individual_features['revenue_growth'] & individual_features['momentum']\n\n# Calculate returns for all combinations\nfactor_return = calc_factor_return(combined_features, labels)\ncumulative_return = (1 + factor_return).cumprod()\n\n# Compare performance\nprint(\"Cumulative Return (Final):\")\nprint(cumulative_return.iloc[-1])\n\nprint(\"\\nAnnualized Return:\")\nprint(factor_return.mean() * 12)\n\nprint(\"\\nAnnualized Volatility:\")\nprint(factor_return.std() * (12 ** 0.5))\n\nprint(\"\\nSharpe Ratio:\")\nprint((factor_return.mean() / factor_return.std()) * (12 ** 0.5))\n\n# Visualization\ncumulative_return.plot(figsize=(14, 6))\nplt.title('Factor Combination Performance Comparison')\nplt.ylabel('Cumulative Return')\nplt.grid(True)\nplt.show()\n```\n\n---\n\n## Best Practices\n\n1. **Use Rank IC for robustness** - Rank IC is more stable than raw IC\n2. **Analyze IC over time** - Look for consistent positive IC, not just average IC\n3. **Check IC trend** - Use calc_regression_stats to identify deteriorating factors\n4. **Calculate Shapley values** - Understand true factor contributions in multi-factor strategies\n5. **Test multiple horizons** - Different factors may work at different time scales\n6. **Combine complementary factors** - Factors with low correlation often work better together\n7. **Monitor factor centrality** - High centrality may indicate overcrowding\n8. **Validate out-of-sample** - Always test on unseen data periods\n\n---\n\n## Related References\n\n- [FinlabDataFrame Reference](dataframe-reference.md) - Enhanced DataFrame methods\n- [Data Reference](data-reference.md) - Available data sources\n- [Factor Examples](factor-examples.md) - Practical factor calculations\n- [Machine Learning Reference](machine-learning-reference.md) - ML-based factor analysis\n- [Backtesting Reference](backtesting-reference.md) - Test factor-based strategies\n",
  "factor-examples": "# Factor Examples and Strategy Reference\n\n## Overview\n\nThis comprehensive guide provides practical examples of factor calculations, stock selection conditions, and complete trading strategies using the FinLab framework. All examples are organized by category for easy reference.\n\n---\n\n## Table of Contents\n\n1. [Common Data Paths](#common-data-paths)\n2. [Technical Indicators](#technical-indicators)\n3. [Calculation Examples](#calculation-examples)\n4. [Stock Selection Conditions](#stock-selection-conditions)\n   - [Technical Analysis](#technical-analysis)\n   - [Fundamental Analysis](#fundamental-analysis)\n   - [Chip Analysis](#chip-analysis)\n   - [Market Indicators](#market-indicators)\n   - [Filter Tools](#filter-tools)\n5. [Complete Strategy Examples](#complete-strategy-examples)\n\n---\n\n## Common Data Paths\n\n```python\nfrom finlab import data\n\n# Price data\nÊî∂Áõ§ÂÉπ = data.get(\"price:Êî∂Áõ§ÂÉπ\")\nÊàê‰∫§ËÇ°Êï∏ = data.get(\"price:Êàê‰∫§ËÇ°Êï∏\")\n\n# Revenue data\nÁï∂ÊúàÁáüÊî∂ = data.get(\"monthly_revenue:Áï∂ÊúàÁáüÊî∂\")\nÂéªÂπ¥ÂêåÊúàÂ¢ûÊ∏õ = data.get(\"monthly_revenue:ÂéªÂπ¥ÂêåÊúàÂ¢ûÊ∏õ(%)\")\n\n# Valuation metrics\nÊú¨ÁõäÊØî = data.get(\"price_earning_ratio:Êú¨ÁõäÊØî\")\nÊÆñÂà©Áéá = data.get(\"price_earning_ratio:ÊÆñÂà©Áéá(%)\")\nËÇ°ÂÉπÊ∑®ÂÄºÊØî = data.get(\"price_earning_ratio:ËÇ°ÂÉπÊ∑®ÂÄºÊØî\")\n\n# Fundamental features\nROEÁ®ÖÂæå = data.get(\"fundamental_features:ROEÁ®ÖÂæå\")\nÁáüÊ•≠ÊØõÂà©Áéá = data.get(\"fundamental_features:ÁáüÊ•≠ÊØõÂà©Áéá\")\nËá™Áî±ÁèæÈáëÊµÅÈáè = data.get(\"fundamental_features:Ëá™Áî±ÁèæÈáëÊµÅÈáè\")\n\n# Market value and institutional trading\nÂ∏ÇÂÄº = data.get(\"etl:market_value\")\nÂ§ñÈô∏Ë≥áË≤∑Ë≥£Ë∂ÖËÇ°Êï∏ = data.get(\"institutional_investors_trading_summary:Â§ñÈô∏Ë≥áË≤∑Ë≥£Ë∂ÖËÇ°Êï∏(‰∏çÂê´Â§ñË≥áËá™ÁáüÂïÜ)\")\nÊäï‰ø°Ë≤∑Ë≥£Ë∂ÖËÇ°Êï∏ = data.get(\"institutional_investors_trading_summary:Êäï‰ø°Ë≤∑Ë≥£Ë∂ÖËÇ°Êï∏\")\n```\n\n---\n\n## Technical Indicators\n\n### Momentum Indicators\n\n```python\nfrom finlab import data\n\n# ADX - Average Directional Index\nadx = data.indicator(\"ADX\", adjust_price=False, resample=\"D\", timeperiod=14)\n\n# RSI - Relative Strength Index\nrsi = data.indicator(\"RSI\", adjust_price=False, resample=\"D\", timeperiod=14)\n\n# MACD - Moving Average Convergence Divergence\nmacd, macdsignal, macdhist = data.indicator(\"MACD\", adjust_price=False, resample=\"D\",\n                                              fastperiod=12, slowperiod=26, signalperiod=9)\n\n# MOM - Momentum\nmom = data.indicator(\"MOM\", adjust_price=False, resample=\"D\", timeperiod=10)\n\n# ROC - Rate of Change\nroc = data.indicator(\"ROC\", adjust_price=False, resample=\"D\", timeperiod=10)\n\n# Stochastic Oscillator\nslowk, slowd = data.indicator(\"STOCH\", adjust_price=False, resample=\"D\",\n                               fastk_period=5, slowk_period=3, slowk_matype=0,\n                               slowd_period=3, slowd_matype=0)\n\n# Williams %R\nwillr = data.indicator(\"WILLR\", adjust_price=False, resample=\"D\", timeperiod=14)\n```\n\n### Moving Averages and Bands\n\n```python\n# Simple Moving Average\nsma = data.indicator(\"SMA\", adjust_price=False, resample=\"D\", timeperiod=30)\n\n# Exponential Moving Average\nema = data.indicator(\"EMA\", adjust_price=False, resample=\"D\", timeperiod=30)\n\n# Bollinger Bands\nupperband, middleband, lowerband = data.indicator(\"BBANDS\", timeperiod=20,\n                                                    nbdevup=2.0, nbdevdn=2.0, matype=0)\n\n# Weighted Moving Average\nwma = data.indicator(\"WMA\", adjust_price=False, resample=\"D\", timeperiod=30)\n\n# TEMA - Triple Exponential Moving Average\ntema = data.indicator(\"TEMA\", adjust_price=False, resample=\"D\", timeperiod=30)\n```\n\n### Volatility Indicators\n\n```python\n# ATR - Average True Range\natr = data.indicator(\"ATR\", adjust_price=False, resample=\"D\", timeperiod=14)\n\n# NATR - Normalized ATR\nnatr = data.indicator(\"NATR\", adjust_price=False, resample=\"D\", timeperiod=14)\n\n# TRANGE - True Range\ntrange = data.indicator(\"TRANGE\", adjust_price=False, resample=\"D\")\n```\n\n### Volume Indicators\n\n```python\n# AD - Chaikin A/D Line\nad = data.indicator(\"AD\", adjust_price=False, resample=\"D\")\n\n# OBV - On Balance Volume\nobv = data.indicator(\"OBV\", adjust_price=False, resample=\"D\")\n\n# ADOSC - Chaikin A/D Oscillator\nadosc = data.indicator(\"ADOSC\", adjust_price=False, resample=\"D\",\n                        fastperiod=3, slowperiod=10)\n```\n\n---\n\n## Calculation Examples\n\n### Price-Based Calculations\n\n```python\nfrom finlab import data\n\nÊî∂Áõ§ÂÉπ = data.get(\"price:Êî∂Áõ§ÂÉπ\")\n\n# 60-day moving average\nsma = Êî∂Áõ§ÂÉπ.average(60)\n\n# 60-day maximum price\nprice_max = Êî∂Áõ§ÂÉπ.rolling(60).max()\n\n# 60-day minimum price\nprice_min = Êî∂Áõ§ÂÉπ.rolling(60).min()\n\n# 20-day price change percentage\nprice_pct = Êî∂Áõ§ÂÉπ.pct_change(periods=20)\n\n# Price rising compared to 60 days ago\nprice_rise = Êî∂Áõ§ÂÉπ.rise(60)\n\n# Price falling compared to 60 days ago\nprice_fall = Êî∂Áõ§ÂÉπ.fall(60)\n\n# Price rising for 3 consecutive days\nrise_sustain = Êî∂Áõ§ÂÉπ.rise().sustain(3)\n\n# Price rising at least 2 out of last 3 days\nrise_nsatisfy = Êî∂Áõ§ÂÉπ.rise().sustain(nwindow=3, nsatisfy=2)\n\n# Price falling for 3 consecutive days\nfall_sustain = Êî∂Áõ§ÂÉπ.fall().sustain(3)\n\n# Top 10 highest prices in market\nprice_largest = Êî∂Áõ§ÂÉπ.is_largest(10)\n\n# Top 10 lowest prices in market\nprice_smallest = Êî∂Áõ§ÂÉπ.is_smallest(10)\n```\n\n### Volume-Based Calculations\n\n```python\nÊàê‰∫§ËÇ°Êï∏ = data.get(\"price:Êàê‰∫§ËÇ°Êï∏\")\n\n# 20-day average volume\nvol_ma = Êàê‰∫§ËÇ°Êï∏.average(20)\n\n# 20-day cumulative volume\nvol_cumsum = Êàê‰∫§ËÇ°Êï∏.rolling(20).sum()\n```\n\n### Revenue-Based Calculations\n\n```python\nÁï∂ÊúàÁáüÊî∂ = data.get(\"monthly_revenue:Áï∂ÊúàÁáüÊî∂\")\nÂéªÂπ¥ÂêåÊúàÂ¢ûÊ∏õ = data.get(\"monthly_revenue:ÂéªÂπ¥ÂêåÊúàÂ¢ûÊ∏õ(%)\")\n\n# 3-month average revenue\nrev_ma = Áï∂ÊúàÁáüÊî∂.average(3)\n\n# Revenue YoY growth > 20% for 3 consecutive months\nrev_rise_sustain = (ÂéªÂπ¥ÂêåÊúàÂ¢ûÊ∏õ > 20).sustain(3)\n\n# Revenue YoY growth ranking (percentile)\nrev_rise_nsatisfy = ÂéªÂπ¥ÂêåÊúàÂ¢ûÊ∏õ.rank(pct=True, axis=1)\n```\n\n### Special Calculations\n\n```python\n# Align position to monthly revenue dates\nrev = data.get(\"monthly_revenue:Áï∂ÊúàÁáüÊî∂\")\nposition = position.reindex(rev.index_str_to_date().index, method=\"ffill\")\n\n# Replace infinity with NaN\ninf_ratio = (data.get(\"financial_statement:Á†îÁ©∂ÁôºÂ±ïË≤ª\") /\n             data.get(\"financial_statement:ÁáüÊ•≠Êî∂ÂÖ•Ê∑®È°ç\")).replace(np.inf, np.nan)\n\n# Inventory - large holders (>400 lots)\ninventory = data.get(\"inventory\")\nboss_inventory = inventory[\n    (inventory.ÊåÅËÇ°ÂàÜÁ¥ö.astype(int) >= 12) &\n    (inventory.ÊåÅËÇ°ÂàÜÁ¥ö.astype(int) <= 15)\n].reset_index().groupby([\"date\", \"stock_id\"]).agg({\n    \"Âç†ÈõÜ‰øùÂ∫´Â≠òÊï∏ÊØî‰æã\": \"sum\"\n}).reset_index().pivot(\"date\", \"stock_id\")[\"Âç†ÈõÜ‰øùÂ∫´Â≠òÊï∏ÊØî‰æã\"]\n\n# Inventory - retail investors (<50 lots)\nsmall_inv = inventory[\n    (inventory.ÊåÅËÇ°ÂàÜÁ¥ö.astype(int) <= 8)\n].reset_index().groupby([\"date\", \"stock_id\"]).agg({\n    \"Âç†ÈõÜ‰øùÂ∫´Â≠òÊï∏ÊØî‰æã\": \"sum\"\n}).reset_index().pivot(\"date\", \"stock_id\")[\"Âç†ÈõÜ‰øùÂ∫´Â≠òÊï∏ÊØî‰æã\"]\n```\n\n---\n\n## Stock Selection Conditions\n\n### Technical Analysis\n\n#### Moving Average Strategies\n\n```python\nÊî∂Áõ§ÂÉπ = data.get(\"price:Êî∂Áõ§ÂÉπ\")\n\n# Price above 60-day MA\nsma60 = Êî∂Áõ§ÂÉπ > Êî∂Áõ§ÂÉπ.average(60)\n\n# Price breaks above 60-day MA\nsma60_breakout = (Êî∂Áõ§ÂÉπ > Êî∂Áõ§ÂÉπ.average(60)) & (Êî∂Áõ§ÂÉπ.shift() < Êî∂Áõ§ÂÉπ.average(60).shift())\n\n# Price breaks below 60-day MA\nsma60_breakdown = (Êî∂Áõ§ÂÉπ < Êî∂Áõ§ÂÉπ.average(60)) & (Êî∂Áõ§ÂÉπ.shift() > Êî∂Áõ§ÂÉπ.average(60).shift())\n\n# Bullish alignment (5/10/20 MA)\nlong_ma_pattern = (Êî∂Áõ§ÂÉπ > Êî∂Áõ§ÂÉπ.average(5)) & (Êî∂Áõ§ÂÉπ > Êî∂Áõ§ÂÉπ.average(10)) & (Êî∂Áõ§ÂÉπ > Êî∂Áõ§ÂÉπ.average(20))\n\n# Bearish alignment (5/10/20 MA)\nshort_ma_pattern = (Êî∂Áõ§ÂÉπ < Êî∂Áõ§ÂÉπ.average(5)) & (Êî∂Áõ§ÂÉπ < Êî∂Áõ§ÂÉπ.average(10)) & (Êî∂Áõ§ÂÉπ < Êî∂Áõ§ÂÉπ.average(20))\n```\n\n#### Price Extreme Conditions\n\n```python\n# New 5-day high\nnew_high = (Êî∂Áõ§ÂÉπ / Êî∂Áõ§ÂÉπ.rolling(5).max()) == 1\n\n# New 5-day low\nnew_low = (Êî∂Áõ§ÂÉπ / Êî∂Áõ§ÂÉπ.rolling(5).min()) == 1\n\n# Making new 3-day highs for 5 consecutive days\nprice_boost = ((Êî∂Áõ§ÂÉπ / Êî∂Áõ§ÂÉπ.rolling(3).max()) == 1).sustain(5)\n\n# Making new 3-day lows for 5 consecutive days\nprice_crash = ((Êî∂Áõ§ÂÉπ / Êî∂Áõ§ÂÉπ.rolling(3).min()) == 1).sustain(5)\n\n# Not making new 3-day highs for 5 consecutive days\nprice_pressure = ((Êî∂Áõ§ÂÉπ / Êî∂Áõ§ÂÉπ.rolling(3).max()) < 1).sustain(5)\n\n# Not making new 3-day lows for 5 consecutive days\nprice_support = ((Êî∂Áõ§ÂÉπ / Êî∂Áõ§ÂÉπ.rolling(3).min()) > 1).sustain(5)\n\n# 20-day price change less than 20%\nprice_pct_cond = Êî∂Áõ§ÂÉπ.pct_change(periods=20) < 0.20\n```\n\n#### Volume Conditions\n\n```python\nÊàê‰∫§ËÇ°Êï∏ = data.get(\"price:Êàê‰∫§ËÇ°Êï∏\")\n\n# 20-day average volume > 1,000,000\nvol_ma = Êàê‰∫§ËÇ°Êï∏.average(20) > 1000000\n\n# Volume above 60-day MA\nvol_ma = Êàê‰∫§ËÇ°Êï∏ > Êàê‰∫§ËÇ°Êï∏.average(60)\n\n# Volume making new 3-day highs for 5 consecutive days\nvol_boost = ((Êàê‰∫§ËÇ°Êï∏ / Êàê‰∫§ËÇ°Êï∏.rolling(3).max()) == 1).sustain(5)\n\n# Volume making new 3-day lows for 5 consecutive days\nvol_crash = ((Êàê‰∫§ËÇ°Êï∏ / Êàê‰∫§ËÇ°Êï∏.rolling(3).min()) == 1).sustain(5)\n```\n\n#### Technical Indicator Conditions\n\n```python\n# RSI golden cross\nrsi1 = data.indicator(\"RSI\", adjust_price=False, resample=\"D\", timeperiod=14)\nrsi2 = data.indicator(\"RSI\", adjust_price=False, resample=\"D\", timeperiod=28)\nrsi_gold_cross = (rsi1 > rsi2) & (rsi1.shift() < rsi2.shift())\n\n# RSI overbought for 5 consecutive days\nrsi = data.indicator(\"RSI\", adjust_price=False, resample=\"D\", timeperiod=5)\nrsi_high_trend = (rsi > 80).sustain(5)\n\n# KD golden cross\nslowk, slowd = data.indicator(\"STOCH\", adjust_price=False, resample=\"D\",\n                               fastk_period=5, slowk_period=3, slowk_matype=0,\n                               slowd_period=3, slowd_matype=0)\nkd_gold_cross = (slowk > slowd) & (slowk.shift() < slowd.shift())\n\n# 10-day volatility (ATR)\nadj_close = data.get(\"etl:adj_close\")\nvolatility = data.indicator(\"ATR\", adjust_price=True, resample=\"D\", timeperiod=10) / adj_close\n\n# Breaking above Keltner Channel upper band\nema = data.indicator(\"EMA\", adjust_price=True, resample=\"D\", timeperiod=10)\natr = data.indicator(\"ATR\", adjust_price=True, resample=\"D\", timeperiod=10)\nkeltner_up = ema + 2 * atr\ncond = (adj_close > keltner_up) & (adj_close.shift() < keltner_up.shift())\n\n# Breaking above Bollinger upper band\nupperband, middleband, lowerband = data.indicator(\"BBANDS\", timeperiod=10)\ncond = (Êî∂Áõ§ÂÉπ > upperband) & (Êî∂Áõ§ÂÉπ.shift() < upperband.shift())\n\n# Breaking below Bollinger lower band\ncond = (Êî∂Áõ§ÂÉπ < lowerband) & (Êî∂Áõ§ÂÉπ.shift() > lowerband.shift())\n\n# MACD golden cross\nmacd, macd_signal, macd_hist = data.indicator(\"MACD\", fastperiod=12, slowperiod=26, signalperiod=9)\nmacd_golden = (macd > macd_signal) & (macd.shift() < macd_signal.shift())\n\n# MACD histogram turns positive\nmacd_hist_positive = (macd_hist > 0) & (macd_hist.shift() < 0)\n\n# RSI oversold breakout (breaks above 30)\nrsi = data.indicator(\"RSI\", timeperiod=14)\nrsi_oversold_breakout = (rsi > 30) & (rsi.shift() < 30)\n\n# RSI overbought breakdown (drops below 70)\nrsi_overbought_breakdown = (rsi < 70) & (rsi.shift() > 70)\n\n# KD low-level golden cross (K < 50)\nslowk, slowd = data.indicator(\"STOCH\", fastk_period=9, slowk_period=3, slowk_matype=0, slowd_period=3, slowd_matype=0)\nkd_low_golden = (slowk > slowd) & (slowk.shift() < slowd.shift()) & (slowk < 50)\n```\n\n---\n\n### Fundamental Analysis\n\n#### Revenue Growth\n\n```python\nÂéªÂπ¥ÂêåÊúàÂ¢ûÊ∏õ = data.get(\"monthly_revenue:ÂéªÂπ¥ÂêåÊúàÂ¢ûÊ∏õ(%)\")\n‰∏äÊúàÊØîËºÉÂ¢ûÊ∏õ = data.get(\"monthly_revenue:‰∏äÊúàÊØîËºÉÂ¢ûÊ∏õ(%)\")\nÁï∂ÊúàÁáüÊî∂ = data.get(\"monthly_revenue:Áï∂ÊúàÁáüÊî∂\")\n\n# Revenue YoY growth > 30%\nrev_yy = ÂéªÂπ¥ÂêåÊúàÂ¢ûÊ∏õ > 30\n\n# Revenue MoM growth > 30%\nrev_mm = ‰∏äÊúàÊØîËºÉÂ¢ûÊ∏õ > 30\n\n# 3-month average revenue > 12-month average revenue\nrev_sl_compare = (Áï∂ÊúàÁáüÊî∂.average(3) > Áï∂ÊúàÁáüÊî∂.average(12))\n\n# 3-month average revenue YoY growth > 12-month average revenue YoY growth\nrev_sl_growth = Áï∂ÊúàÁáüÊî∂.average(3).pct_change(12) > Áï∂ÊúàÁáüÊî∂.average(12).pct_change(12)\n\n# 2-month average revenue at 12-month high\nrev_new_high = (Áï∂ÊúàÁáüÊî∂.average(2) / Áï∂ÊúàÁáüÊî∂.average(2).rolling(12, min_periods=6).max()) == 1\n\n# At least 2 out of last 3 months with YoY growth > 20%\nrev_rise_nsatisfy = (ÂéªÂπ¥ÂêåÊúàÂ¢ûÊ∏õ > 20).sustain(nwindow=3, nsatisfy=2)\n\n# Revenue YoY growth ranking > 80th percentile\nrev_rise_nsatisfy = ÂéªÂπ¥ÂêåÊúàÂ¢ûÊ∏õ.rank(pct=True, axis=1) > 0.80\n```\n\n#### Valuation Metrics\n\n```python\nÊú¨ÁõäÊØî = data.get(\"price_earning_ratio:Êú¨ÁõäÊØî\")\nËÇ°ÂÉπÊ∑®ÂÄºÊØî = data.get(\"price_earning_ratio:ËÇ°ÂÉπÊ∑®ÂÄºÊØî\")\nÊÆñÂà©Áéá = data.get(\"price_earning_ratio:ÊÆñÂà©Áéá(%)\")\n\n# PE ratio between 5 and 20\npe_range = (5 <= Êú¨ÁõäÊØî) & (Êú¨ÁõäÊØî <= 20)\n\n# PB ratio between 0.5 and 2\npb_range = (0.5 <= ËÇ°ÂÉπÊ∑®ÂÄºÊØî) & (ËÇ°ÂÉπÊ∑®ÂÄºÊØî <= 2)\n\n# Dividend yield between 3% and 10%\nyield_range = (3 <= ÊÆñÂà©Áéá) & (ÊÆñÂà©Áéá <= 10)\n```\n\n#### Profitability Metrics\n\n```python\nÁáüÈÅãÁèæÈáëÊµÅ = data.get(\"fundamental_features:ÁáüÈÅãÁèæÈáëÊµÅ\")\nÁáüÊ•≠ÊØõÂà©Áéá = data.get(\"fundamental_features:ÁáüÊ•≠ÊØõÂà©Áéá\")\nÁáüÊ•≠Âà©ÁõäÁéá = data.get(\"fundamental_features:ÁáüÊ•≠Âà©ÁõäÁéá\")\nÁ®ÖÂâçÊ∑®Âà©Áéá = data.get(\"fundamental_features:Á®ÖÂâçÊ∑®Âà©Áéá\")\nÁ®ÖÂæåÊ∑®Âà©Áéá = data.get(\"fundamental_features:Á®ÖÂæåÊ∑®Âà©Áéá\")\nÊ•≠Â§ñÊî∂ÊîØÁáüÊî∂Áéá = data.get(\"fundamental_features:Ê•≠Â§ñÊî∂ÊîØÁáüÊî∂Áéá\")\nÊØèËÇ°ÁõàÈ§ò = data.get(\"financial_statement:ÊØèËÇ°ÁõàÈ§ò\")\nROAÁ∂úÂêàÊêçÁõä = data.get(\"fundamental_features:ROAÁ∂úÂêàÊêçÁõä\")\nROEÁ∂úÂêàÊêçÁõä = data.get(\"fundamental_features:ROEÁ∂úÂêàÊêçÁõä\")\n\n# Operating cash flow > 0 for 1 quarter\nope_cashflow_trend = (ÁáüÈÅãÁèæÈáëÊµÅ > 0).sustain(1)\n\n# Gross margin > 3% for 1 quarter\ngpm_trend = (ÁáüÊ•≠ÊØõÂà©Áéá > 3).sustain(1)\n\n# Operating margin > 3% for 1 quarter\nopm_trend = (ÁáüÊ•≠Âà©ÁõäÁéá > 3).sustain(1)\n\n# Pre-tax margin > 3% for 1 quarter\nbtpm_trend = (Á®ÖÂâçÊ∑®Âà©Áéá > 3).sustain(1)\n\n# After-tax margin > 3% for 1 quarter\natpm_trend = (Á®ÖÂæåÊ∑®Âà©Áéá > 3).sustain(1)\n\n# Non-operating income ratio > 3% for 1 quarter\nopm_trend = (Ê•≠Â§ñÊî∂ÊîØÁáüÊî∂Áéá > 3).sustain(1)\n\n# EPS > 0 for 4 consecutive quarters\neps_trend = (ÊØèËÇ°ÁõàÈ§ò > 0).sustain(4)\n\n# ROA > 0% for 4 consecutive quarters\nroa_trend = (ROAÁ∂úÂêàÊêçÁõä > 0).sustain(4)\n\n# ROE > 0% for 4 consecutive quarters\nroe_trend = (ROEÁ∂úÂêàÊêçÁõä > 0).sustain(4)\n```\n\n#### Leverage Metrics\n\n```python\nË≤†ÂÇµÊØîÁéá = data.get(\"fundamental_features:Ë≤†ÂÇµÊØîÁéá\")\n\n# Debt ratio < 50% for 4 consecutive quarters\ndebt_trend = (Ë≤†ÂÇµÊØîÁéá < 50).sustain(4)\n```\n\n---\n\n### Chip Analysis\n\n#### Institutional Trading\n\n```python\nfrom finlab import data\n\n# Foreign institutional net buy ratio > 10% in 1 day\niit = data.get(\"institutional_investors_trading_summary:Â§ñÈô∏Ë≥áË≤∑Ë≥£Ë∂ÖËÇ°Êï∏(‰∏çÂê´Â§ñË≥áËá™ÁáüÂïÜ)\")\nvol = data.get(\"price:Êàê‰∫§ËÇ°Êï∏\")\niit_ratio = iit.rolling(1).sum() / vol.rolling(1).sum() > 0.1\n\n# Investment trust net buy ratio > 10% in 1 day\nÊäï‰ø°Ë≤∑Ë≥£Ë∂ÖËÇ°Êï∏ = data.get(\"institutional_investors_trading_summary:Êäï‰ø°Ë≤∑Ë≥£Ë∂ÖËÇ°Êï∏\")\nÊàê‰∫§ËÇ°Êï∏ = data.get(\"price:Êàê‰∫§ËÇ°Êï∏\")\nict_ratio = Êäï‰ø°Ë≤∑Ë≥£Ë∂ÖËÇ°Êï∏.rolling(1).sum() / Êàê‰∫§ËÇ°Êï∏.rolling(1).sum() > 0.1\n\n# Foreign net buy > 200,000 shares for 2 consecutive days\nitt = data.get(\"institutional_investors_trading_summary:Â§ñÈô∏Ë≥áË≤∑Ë≥£Ë∂ÖËÇ°Êï∏(‰∏çÂê´Â§ñË≥áËá™ÁáüÂïÜ)\")\nitt_trend = (itt > 200000).sustain(2)\n\n# Investment trust net buy > 200,000 shares for 2 consecutive days\nict_trend = (Êäï‰ø°Ë≤∑Ë≥£Ë∂ÖËÇ°Êï∏ > 200000).sustain(2)\n\n# Three major institutional investors all buying (‰∏âÂ§ßÊ≥ï‰∫∫ÂêåË≤∑)\nÂ§ñË≥á = data.get(\"institutional_investors_trading_summary:Â§ñÈô∏Ë≥áË≤∑Ë≥£Ë∂ÖËÇ°Êï∏(‰∏çÂê´Â§ñË≥áËá™ÁáüÂïÜ)\")\nÊäï‰ø° = data.get(\"institutional_investors_trading_summary:Êäï‰ø°Ë≤∑Ë≥£Ë∂ÖËÇ°Êï∏\")\nËá™ÁáüÂïÜ = data.get(\"institutional_investors_trading_summary:Ëá™ÁáüÂïÜË≤∑Ë≥£Ë∂ÖËÇ°Êï∏(Ëá™Ë°åË≤∑Ë≥£)\")\n‰∏âÂ§ßÊ≥ï‰∫∫ÂêåË≤∑ = (Â§ñË≥á > 0) & (Êäï‰ø° > 0) & (Ëá™ÁáüÂïÜ > 0)\nÈÄ£Á∫åÂêåË≤∑ = ‰∏âÂ§ßÊ≥ï‰∫∫ÂêåË≤∑.sustain(3)\nposition = Â§ñË≥á[ÈÄ£Á∫åÂêåË≤∑].is_largest(10)\n```\n\n#### Shareholding Distribution\n\n```python\ninventory = data.get(\"inventory\")\nËë£Áõ£ÊåÅÊúâËÇ°Êï∏Âç†ÊØî = data.get(\"internal_equity_changes:Ëë£Áõ£ÊåÅÊúâËÇ°Êï∏Âç†ÊØî\")\n\n# Large holders (>400 lots) shareholding >= 30%\nboss_inv = inventory[\n    (inventory.ÊåÅËÇ°ÂàÜÁ¥ö.astype(int) >= 12) &\n    (inventory.ÊåÅËÇ°ÂàÜÁ¥ö.astype(int) <= 15)\n].reset_index().groupby([\"date\", \"stock_id\"]).agg({\n    \"Âç†ÈõÜ‰øùÂ∫´Â≠òÊï∏ÊØî‰æã\": \"sum\"\n}).reset_index().pivot(\"date\", \"stock_id\")[\"Âç†ÈõÜ‰øùÂ∫´Â≠òÊï∏ÊØî‰æã\"] >= 30\n\n# Large holders (>800 lots) shareholding >= 30%\nboss_inv = inventory[\n    (inventory.ÊåÅËÇ°ÂàÜÁ¥ö.astype(int) >= 14) &\n    (inventory.ÊåÅËÇ°ÂàÜÁ¥ö.astype(int) <= 15)\n].reset_index().groupby([\"date\", \"stock_id\"]).agg({\n    \"Âç†ÈõÜ‰øùÂ∫´Â≠òÊï∏ÊØî‰æã\": \"sum\"\n}).reset_index().pivot(\"date\", \"stock_id\")[\"Âç†ÈõÜ‰øùÂ∫´Â≠òÊï∏ÊØî‰æã\"] >= 30\n\n# Large holders (>400 lots) increasing for 3 consecutive periods\nfrom finlab import dataframe\nboss_inv_trend = dataframe.FinlabDataFrame(\n    inventory[\n        (inventory.ÊåÅËÇ°ÂàÜÁ¥ö.astype(int) >= 12) &\n        (inventory.ÊåÅËÇ°ÂàÜÁ¥ö.astype(int) <= 15)\n    ].reset_index().groupby([\"date\", \"stock_id\"]).agg({\n        \"Âç†ÈõÜ‰øùÂ∫´Â≠òÊï∏ÊØî‰æã\": \"sum\"\n    }).reset_index().pivot(\"date\", \"stock_id\")[\"Âç†ÈõÜ‰øùÂ∫´Â≠òÊï∏ÊØî‰æã\"]\n).rise().sustain(3)\n\n# Retail investors (<50 lots) shareholding <= 30%\nsmall_inv = inventory[\n    (inventory.ÊåÅËÇ°ÂàÜÁ¥ö.astype(int) <= 8)\n].reset_index().groupby([\"date\", \"stock_id\"]).agg({\n    \"Âç†ÈõÜ‰øùÂ∫´Â≠òÊï∏ÊØî‰æã\": \"sum\"\n}).reset_index().pivot(\"date\", \"stock_id\")[\"Âç†ÈõÜ‰øùÂ∫´Â≠òÊï∏ÊØî‰æã\"] <= 30\n\n# Retail investors (<50 lots) decreasing for 3 consecutive periods\nfrom finlab import dataframe\nsmall_inv_trend = dataframe.FinlabDataFrame(\n    inventory[\n        (inventory.ÊåÅËÇ°ÂàÜÁ¥ö.astype(int) <= 8)\n    ].reset_index().groupby([\"date\", \"stock_id\"]).agg({\n        \"Âç†ÈõÜ‰øùÂ∫´Â≠òÊï∏ÊØî‰æã\": \"sum\"\n    }).reset_index().pivot(\"date\", \"stock_id\")[\"Âç†ÈõÜ‰øùÂ∫´Â≠òÊï∏ÊØî‰æã\"]\n).fall().sustain(3)\n\n# Total number of shareholders decreasing for 3 consecutive periods\ninv_small_people_trend = dataframe.FinlabDataFrame(\n    inventory[\n        (inventory.‰∫∫Êï∏.astype(int) == 17)\n    ].reset_index().groupby([\"date\", \"stock_id\"]).agg({\n        \"‰∫∫Êï∏\": \"sum\"\n    }).reset_index().pivot(\"date\", \"stock_id\")[\"‰∫∫Êï∏\"]\n).fall().sustain(3)\n\n# Director/supervisor shareholding > 30%\nboss_hold = Ëë£Áõ£ÊåÅÊúâËÇ°Êï∏Âç†ÊØî > 30\n\n# Director/supervisor shareholding increasing compared to 1 month ago\nboss_hold_rise = Ëë£Áõ£ÊåÅÊúâËÇ°Êï∏Âç†ÊØî.rise(1)\n```\n\n#### Day Trading and Margin\n\n```python\nÁï∂Êó•Ê≤ñÈä∑‰∫§ÊòìÊàê‰∫§ËÇ°Êï∏ = data.get(\"intraday_trading:Áï∂Êó•Ê≤ñÈä∑‰∫§ÊòìÊàê‰∫§ËÇ°Êï∏\")\nÊàê‰∫§ËÇ°Êï∏ = data.get(\"price:Êàê‰∫§ËÇ°Êï∏\")\nËûçË≥á‰ΩøÁî®Áéá = data.get(\"margin_transactions:ËûçË≥á‰ΩøÁî®Áéá\")\nËûçÂà∏‰ΩøÁî®Áéá = data.get(\"margin_transactions:ËûçÂà∏‰ΩøÁî®Áéá\")\nËûçÂà∏‰ªäÊó•È§òÈ°ç = data.get(\"margin_transactions:ËûçÂà∏‰ªäÊó•È§òÈ°ç\")\nËûçË≥á‰ªäÊó•È§òÈ°ç = data.get(\"margin_transactions:ËûçË≥á‰ªäÊó•È§òÈ°ç\")\n\n# Day trading ratio < 10%\nday_trade_ratio = Áï∂Êó•Ê≤ñÈä∑‰∫§ÊòìÊàê‰∫§ËÇ°Êï∏ / Êàê‰∫§ËÇ°Êï∏ / 2 < 0.1\n\n# Margin utilization > 0% for 1 day\nmargin_used_raio = (ËûçË≥á‰ΩøÁî®Áéá > 0).sustain(1)\n\n# Short selling utilization > 0% for 1 day\nmargin_sell_used_raio = (ËûçÂà∏‰ΩøÁî®Áéá > 0).sustain(1)\n\n# Short/Margin ratio > 0% for 1 day\nmargin_trend = (ËûçÂà∏‰ªäÊó•È§òÈ°ç / ËûçË≥á‰ªäÊó•È§òÈ°ç > 0).sustain(1)\n```\n\n---\n\n### Market Indicators\n\n```python\n# ADLs (Advance-Decline Line with Smoothing)\ndef ADLs_position(short_par=20, long_par=55):\n    close = data.get(\"price:Êî∂Áõ§ÂÉπ\")\n    close_diff = close.diff()\n    total_stocks = (~close.isna()).sum(1)\n    rise_stocks = (close_diff > 0).sum(1)\n    ADLs = rise_stocks / total_stocks - 0.5\n    short_ADLs_ma = ADLs.rolling(short_par).mean()\n    long_ADLs_ma = ADLs.rolling(long_par).mean()\n    cond = ~close.isna()\n    cond1 = short_ADLs_ma >= long_ADLs_ma\n    position = cond & cond1\n    return position\n\n# VIX (Volatility Index)\ndef vix_position(short_par=5, long_par=20):\n    df = data.get(\"world_index:open\")\n    vix = df[\"^VIX\"].dropna()\n    short_vix_ma = vix.rolling(short_par).mean()\n    long_vix_ma = vix.rolling(long_par).mean()\n    close = data.get(\"price:Êî∂Áõ§ÂÉπ\")\n    cond = ~close.isna()\n    cond1 = short_vix_ma <= long_vix_ma\n    cond1 = cond1.reindex(close.index)\n    position = cond & cond1\n    return position\n\n# Market Long/Short Alignment Count\ndef ls_order_position(short=5, mid=10, long=30):\n    close = data.get(\"price:Êî∂Áõ§ÂÉπ\")\n    short_ma = close.average(short)\n    mid_ma = close.average(mid)\n    long_ma = close.average(long)\n    long_order = (short_ma >= mid_ma) & (mid_ma >= long_ma)\n    long_order = long_order.sum(1)\n    short_order = (short_ma < mid_ma) & (mid_ma < long_ma)\n    short_order = short_order.sum(1)\n    entry = long_order > short_order\n    cond = ~close.isna()\n    position = cond & entry\n    return position\n\n# Margin Maintenance Ratio\ndef margin_position(short_par=5, long_par=30):\n    ËûçË≥áÂà∏Á∏ΩÈ§òÈ°ç = data.get(\"margin_balance:ËûçË≥áÂà∏Á∏ΩÈ§òÈ°ç\").fillna(method=\"ffill\")\n    ËûçË≥á‰ªäÊó•È§òÈ°ç = data.get(\"margin_transactions:ËûçË≥á‰ªäÊó•È§òÈ°ç\")\n    close = data.get(\"price:Êî∂Áõ§ÂÉπ\")\n    ËûçË≥áÁ∏ΩÈ§òÈ°ç = ËûçË≥áÂà∏Á∏ΩÈ§òÈ°ç[[\"‰∏äÂ∏ÇËûçË≥á‰∫§ÊòìÈáëÈ°ç\", \"‰∏äÊ´ÉËûçË≥á‰∫§ÊòìÈáëÈ°ç\"]].sum(axis=1)\n    ËûçË≥áÈ§òÈ°çÂ∏ÇÂÄº = (ËûçË≥á‰ªäÊó•È§òÈ°ç * close * 1000).sum(axis=1)[ËûçË≥á‰ªäÊó•È§òÈ°ç.index]\n    mt_rate = (ËûçË≥áÈ§òÈ°çÂ∏ÇÂÄº / ËûçË≥áÁ∏ΩÈ§òÈ°ç)\n    mt_rate = mt_rate.dropna()\n    short_ma = mt_rate.rolling(short_par).mean()\n    long_ma = mt_rate.rolling(long_par).mean()\n    entry = short_ma >= long_ma\n    cond = ~close.isna()\n    position = cond & entry\n    return position\n```\n\n---\n\n### Filter Tools\n\n```python\nfrom finlab import data\n\n# Filter out attention stocks\nnoticed_stock_filter = data.get(\"etl:noticed_stock_filter\")\n\n# Filter out disposal stocks\ndisposal_stock_filter = data.get(\"etl:disposal_stock_filter\")\n\n# Filter out full cash delivery stocks\nfull_cash_delivery_stock_filter = data.get(\"etl:full_cash_delivery_stock_filter\")\n\n# Filter out KY stocks\nsc = data.get(\"security_categories\")\nposition_col = position.columns\nky_filter = position_col[~position_col.isin(list(sc[sc[\"name\"].str.contains(\"KY\")][\"stock_id\"]))]\nposition = position[ky_filter]\n\n# Limit backtest to specific industry\ndata.set_universe(market=\"TSE_OTC\", category=\"Âª∫ÊùêÁáüÈÄ†\")\n```\n\n---\n\n## Complete Strategy Examples\n\n### 1. New High Strategy\n\nSelect stocks making 250-day new highs.\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\nclose = data.get(\"price:Êî∂Áõ§ÂÉπ\")\nposition = (close == close.rolling(250).max())\nsim(position, resample=\"M\", name=\"ÂâµÂπ¥Êñ∞È´òÁ≠ñÁï•\")\n```\n\n---\n\n### 2. Revenue Momentum Strategy\n\nSelect stocks with strong recent revenue performance.\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\nimport pandas as pd\n\nrev = data.get(\"monthly_revenue:Áï∂ÊúàÁáüÊî∂\")\nrev_rf = data.get(\"monthly_revenue:ÂéªÂπ¥ÂêåÊúàÂ¢ûÊ∏õ(%)\")\nvol = data.get(\"price:Êàê‰∫§ËÇ°Êï∏\") / 1000\n\nrev_recent_3 = rev.rolling(3).sum()\nvol_avg = vol.average(10)\n\ncond1 = (rev_recent_3 / rev_recent_3.rolling(24, min_periods=12).max()) == 1\ncond2 = vol_avg > 300\ncond_all = cond1 & cond2\n\nresult = rev_rf * (cond_all)\nposition = result[result > 0].is_largest(10).reindex(rev.index_str_to_date().index, method=\"ffill\")\n\nsim(position=position, stop_loss=0.3, position_limit=0.1)\n```\n\n---\n\n### 3. Cash Flow Strategy\n\nSelect stocks with positive cash flows across all categories.\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\nÁáüÊ•≠ÁèæÈáëÊµÅ = data.get(\"financial_statement:ÁáüÊ•≠Ê¥ªÂãï‰πãÊ∑®ÁèæÈáëÊµÅÂÖ•_ÊµÅÂá∫\")\nÊäïË≥áÁèæÈáëÊµÅ = data.get(\"financial_statement:ÊäïË≥áÊ¥ªÂãï‰πãÊ∑®ÁèæÈáëÊµÅÂÖ•_ÊµÅÂá∫\")\nËûçË≥áÁèæÈáëÊµÅ = data.get(\"financial_statement:Á±åË≥áÊ¥ªÂãï‰πãÊ∑®ÁèæÈáëÊµÅÂÖ•_ÊµÅÂá∫\")\n\nposition = (ÁáüÊ•≠ÁèæÈáëÊµÅ > 0) & (ÊäïË≥áÁèæÈáëÊµÅ > 0) & (ËûçË≥áÁèæÈáëÊµÅ > 0)\nreport = sim(position, resample=\"M\", name=\"ÁèæÈáëÊµÅÊ≠£Êï∏\")\n```\n\n---\n\n### 4. PEG Strategy\n\nPrice-Earnings to Growth ratio strategy.\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\npe = data.get(\"price_earning_ratio:Êú¨ÁõäÊØî\")\nrev = data.get(\"monthly_revenue:Áï∂ÊúàÁáüÊî∂\")\nrev_ma3 = rev.average(3)\nrev_ma12 = rev.average(12)\nÁáüÊ•≠Âà©ÁõäÊàêÈï∑Áéá = data.get(\"fundamental_features:ÁáüÊ•≠Âà©ÁõäÊàêÈï∑Áéá\")\n\npeg = (pe / ÁáüÊ•≠Âà©ÁõäÊàêÈï∑Áéá)\ncond1 = rev_ma3 / rev_ma12 > 1.1\ncond2 = rev / rev.shift(1) > 0.9\ncond_all = cond1 & cond2\n\nresult = peg * (cond_all)\nposition = result[result > 0].is_smallest(10).reindex(rev.index_str_to_date().index, method=\"ffill\")\n\nsim(position=position, name=\"peg_rev\", fee_ratio=1.425/1000/3, stop_loss=0.1)\n```\n\n---\n\n### 5. Momentum + ROE Filter Strategy\n\nCombine price momentum with ROE filter.\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\n# Download ROE and closing price\nroe = data.get(\"fundamental_features:ROEÁ®ÖÂæå\")\nclose = data.get(\"price:Êî∂Áõ§ÂÉπ\")\n\nposition = ((close / close.shift(60)).is_largest(30) & (roe > 0))\n\n# Backtest, rebalance monthly (M)\nreport = sim(position, resample=\"M\")\n```\n\n---\n\n### 6. Low PB Strategy\n\nPrice-to-Book ratio strategy with technical filter.\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\npb = data.get(\"price_earning_ratio:ËÇ°ÂÉπÊ∑®ÂÄºÊØî\")\nclose = data.get(\"price:Êî∂Áõ§ÂÉπ\")\n\nbuy = (1 / (pb * close) * (close > close.average(60)) * (close > 5)).is_largest(20)\nsim(buy, resample=\"Q\")\n```\n\n---\n\n### 7. Triple RSI Strategy\n\nAdvanced RSI-based strategy with multiple timeframes.\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\nimport pandas as pd\nfrom finlab import dataframe\n\nclose = data.get(\"price:Êî∂Áõ§ÂÉπ\")\nroe = data.get(\"fundamental_features:ROEÁ®ÖÂæå\")\n\nrsi1 = data.indicator(\"RSI\", timeperiod=20)\nrsi2 = data.indicator(\"RSI\", freq=\"D\", timeperiod=60)\nrsi3 = data.indicator(\"RSI\", freq=\"D\", timeperiod=120)\n\nbuy = (rsi3 > 55) & (rsi1 / rsi1.shift(3) > 1.02) & (roe > 0) & \\\n      dataframe.FinlabDataFrame(rsi1 > 75).sustain(3) & (rsi2 < 75)\nsell = buy.shift(60) | (close < close.average(60))\n\nposition = pd.DataFrame(np.nan, index=buy.index, columns=buy.columns)\nposition[buy] = 1\nposition[sell] = 0\nposition = position.ffill().fillna(0)\n\nreport = sim(position.loc[\"2014\":], resample=\"W\")\n```\n\n---\n\n### 8. High RSI Strategy\n\nSimple high RSI momentum strategy.\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\nrsi = data.indicator(\"RSI\")\nposition = rsi.is_largest(20)\nreport = sim(position, resample=\"W\", name=\"È´òRSIÁ≠ñÁï•\")\n```\n\n---\n\n### 9. Entry/Exit Signal Example\n\nUsing hold_until for explicit entry and exit signals.\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\nclose = data.get(\"price:Êî∂Áõ§ÂÉπ\")\npb = data.get(\"price_earning_ratio:ËÇ°ÂÉπÊ∑®ÂÄºÊØî\")\n\nsma20 = close.average(20)\nsma60 = close.average(60)\n\nentries = close > sma20\nexits = close < sma60\n\nposition = entries.hold_until(exits, nstocks_limit=10, rank=-pb)\nsim(position)\n```\n\n---\n\n### 10. Long/Short Strategy\n\nExample of simultaneous long and short positions.\n\n```python\nfrom finlab import data\nfrom finlab import backtest\n\nclose = data.get(\"price:Êî∂Áõ§ÂÉπ\")\nposition = close < 0  # Start with all False\n\nposition[\"2330\"] = 0.5   # Long TSMC with 50% weight\nposition[\"1101\"] = -0.5  # Short Taiwan Cement with 50% weight\n\nreport = backtest.sim(position)\n```\n\n---\n\n## Best Practices\n\n1. **Use vectorized operations** - Never use for loops on FinlabDataFrame\n2. **Set appropriate resample periods** - Use 'M', 'Q', or revenue.index to avoid overtrading\n3. **Combine multiple factors** - Single factor strategies are often less robust\n4. **Apply filters** - Remove special status stocks (disposal, attention, full cash delivery)\n5. **Control position size** - Use position_limit and nstocks_limit\n6. **Set stop loss/take profit** - Protect against large losses\n7. **Universe filtering** - Use data.universe() to scope data.get() calls only\n8. **Proper alignment** - Let FinlabDataFrame handle index/column alignment automatically\n\n---\n\n## Related References\n\n- [FinlabDataFrame Reference](dataframe-reference.md) - Enhanced DataFrame methods\n- [Backtesting Reference](backtesting-reference.md) - Backtest your strategies\n- [Data Reference](data-reference.md) - Complete data catalog\n- [Factor Analysis Reference](factor-analysis-reference.md) - Analyze factor performance\n- [Machine Learning Reference](machine-learning-reference.md) - ML-based strategies\n",
  "machine-learning-reference": "# Machine Learning Reference\n\n## Overview\n\nThe FinLab machine learning module provides tools for creating ML-based trading strategies. It includes feature engineering, label generation, and integration with popular ML libraries like scikit-learn, XGBoost, and LightGBM.\n\n**Import:**\n```python\nfrom finlab.ml import feature, label\n```\n\n---\n\n## Table of Contents\n\n1. [Feature Engineering](#feature-engineering)\n2. [Label Generation](#label-generation)\n3. [Complete ML Workflow](#complete-ml-workflow)\n4. [Best Practices](#best-practices)\n\n---\n\n## Feature Engineering\n\n### feature.ta_names\n\nGenerate a list of technical indicator feature names with randomized parameters.\n\n**Signature:**\n```python\nfeature.ta_names(\n    lb: int = 1,\n    ub: int = 10,\n    n: int = 1,\n    factory: Optional[Factory] = None\n) -> List[str]\n```\n\n**Parameters:**\n- `lb` (int, optional, default=1): Lower bound of the multiplier for default technical indicator parameters\n- `ub` (int, optional, default=10): Upper bound of the multiplier for default technical indicator parameters\n- `n` (int, optional, default=1): Number of random samples for each technical indicator\n- `factory` (optional, default=None): Factory object to generate technical indicators. Defaults to TalibIndicatorFactory\n\n**Returns:**\n- `List[str]`: A list of technical indicator feature names\n\n**Example:**\n```python\nimport finlab.ml.feature as f\n\n# Generate 5 random variations for each TA-Lib indicator\nfeature_names = f.ta_names(n=5)\nprint(feature_names[:10])\n```\n\n---\n\n### feature.ta\n\nCalculate technical indicator values for a list of feature names.\n\n**Signature:**\n```python\nfeature.ta(\n    feature_names: Optional[List[str]],\n    factories = None,\n    resample = None,\n    start_time = None,\n    end_time = None,\n    adj = False,\n    cpu = -1,\n    **kwargs\n) -> pd.DataFrame\n```\n\n**Parameters:**\n- `feature_names` (list, optional, default=None): List of technical indicator feature names. Defaults to None (generates default names)\n- `factories` (dict, optional, default=None): Dictionary of factories to generate technical indicators. Defaults to {'talib': TalibIndicatorFactory()}\n- `resample` (str, optional, default=None): Frequency to resample data (e.g., 'W', 'M'). Defaults to None\n- `start_time` (str, optional, default=None): Start time of the data\n- `end_time` (str, optional, default=None): End time of the data\n- `adj` (bool, optional, default=False): Whether to use adjusted prices\n- `cpu` (int, optional, default=-1): Number of CPU cores for parallel processing. -1 uses all available cores\n- `**kwargs`: Additional keyword arguments to pass to the resampler function\n\n**Returns:**\n- `pd.DataFrame`: Technical indicator feature names and values, indexed by ('datetime', 'instrument')\n\n**Example:**\n```python\nimport finlab.ml.feature as f\n\n# Method 1: Generate default indicators with random parameters\nfeatures1 = f.ta()\nprint(features1.head())\n\n# Method 2: Generate specific indicator with defined parameters, resampled weekly\nfeature_names = ['talib.MACD__macdhist__fastperiod__52__slowperiod__212__signalperiod__75__']\nfeatures2 = f.ta(feature_names, resample='W')\nprint(features2.head())\n```\n\n**Important Notes:**\n- `feature.ta` can only calculate values for feature names generated by `feature.ta_names` randomly\n- Do NOT use `feature.ta` and `feature.ta_names` by default. Use `data.indicator` instead for static feature names\n- If you want static feature names, use `data.indicator('SMA', timeperiod=20)` which supports all TA-Lib indicators\n\n---\n\n### feature.combine\n\nCombine multiple feature DataFrames into a single DataFrame.\n\n**Signature:**\n```python\nfeature.combine(\n    features: Dict[str, pd.DataFrame],\n    resample = None,\n    sample_filter = None,\n    **kwargs\n)\n```\n\n**Parameters:**\n- `features` (dict, required): Dictionary where keys are feature names and values are DataFrames (index=datetime, columns=instrument)\n- `resample` (str, optional, default=None): Optional argument to resample data in features (e.g., 'W', 'M')\n- `sample_filter` (pd.DataFrame, optional, default=None): Boolean DataFrame (index=date, columns=instrument) representing the filter of features\n- `**kwargs`: Additional keyword arguments to pass to the resampler function\n\n**Returns:**\n- `pd.DataFrame`: All input features combined, indexed by ('datetime', 'instrument')\n\n**Example:**\n```python\nfrom finlab import data\nimport finlab.ml.feature as f\n\nfeatures_dict = {\n    'pb': data.get('price_earning_ratio:ËÇ°ÂÉπÊ∑®ÂÄºÊØî'),\n    'rsi': data.indicator('RSI')\n}\n\ncombined_features = f.combine(features_dict, resample='M')\nprint(combined_features.head())\n```\n\n**Important Notes:**\n- `feature.combine` can handle misaligned indices and missing data automatically\n- Set `resample` to 'W', '2W', `data.get(\"monthly_revenue:Áï∂ÊúàÁáüÊî∂\").index`, `data.get(\"fundamental_features:ROEÁ®ÖÂæå\").deadline().index`, 'ME', 'QE', etc. to avoid excessive data points and high RAM consumption\n- Use `sample_filter` parameter to filter unwanted data points (e.g., `sample_filter = data.get('price:Êàê‰∫§ËÇ°Êï∏') > 200_000`)\n\n---\n\n## Label Generation\n\n### label.return_percentage\n\nCalculate the percentage change of market prices over a given period.\n\n**Signature:**\n```python\nlabel.return_percentage(\n    index: pd.Index,\n    resample = None,\n    period = 1,\n    trade_at_price = 'close',\n    bfill = False,\n    **kwargs\n)\n```\n\n**Parameters:**\n- `index` (pd.Index, required): Multi-level index of datetime and instrument\n- `resample` (str, optional, default=None): Resample frequency for output data (e.g., 'W', 'M')\n- `period` (int, optional, default=1): Number of periods to calculate percentage change over\n- `trade_at_price` (str, optional, default='close'): Price for execution ('open', 'high', 'low', 'close')\n- `bfill` (bool, optional, default=False): Whether to backfill missing price data before calculation\n- `**kwargs`: Additional arguments passed to resampler function\n\n**Returns:**\n- `pd.Series`: Percentage change of stock prices, aligned to input index\n\n**Example:**\n```python\nfrom finlab.ml import label\n\n# Assume features is your feature DataFrame\ny = label.return_percentage(features.index, resample='M', period=1)\n```\n\n---\n\n### label.excess_over_mean\n\nCalculate the excess return over the cross-sectional mean return for a given period.\n\n**Signature:**\n```python\nlabel.excess_over_mean(\n    index: pd.Index,\n    resample = None,\n    period = 1,\n    trade_at_price = 'close',\n    **kwargs\n)\n```\n\n**Parameters:**\n- `index` (pd.Index, required): Multi-level index of datetime and instrument\n- `resample` (str, optional, default=None): Resample frequency (e.g., 'W', 'M')\n- `period` (int, optional, default=1): Number of periods for return calculation\n- `trade_at_price` (str, optional, default='close'): Price for return calculation ('open', 'high', 'low', 'close')\n- `**kwargs`: Additional arguments passed to resampler function\n\n**Returns:**\n- `pd.Series`: Excess return over the mean, aligned to input index\n\n**Example:**\n```python\nfrom finlab.ml import label\n\n# Excess return over market mean\ny = label.excess_over_mean(features.index, resample='M', period=1)\n```\n\n---\n\n### label.excess_over_median\n\nCalculate the excess return over the cross-sectional median return for a given period.\n\n**Signature:**\n```python\nlabel.excess_over_median(\n    index: pd.Index,\n    resample = None,\n    period = 1,\n    trade_at_price = 'close',\n    **kwargs\n)\n```\n\n**Parameters:**\n- `index` (pd.Index, required): Multi-level index of datetime and instrument\n- `resample` (str, optional, default=None): Resample frequency (e.g., 'W', 'M')\n- `period` (int, optional, default=1): Number of periods for return calculation\n- `trade_at_price` (str, optional, default='close'): Price for return calculation\n- `**kwargs`: Additional arguments passed to resampler function\n\n**Returns:**\n- `pd.Series`: Excess return over the median, aligned to input index\n\n---\n\n### label.daytrading_percentage\n\nCalculate the intraday percentage change (close / open - 1).\n\n**Signature:**\n```python\nlabel.daytrading_percentage(\n    index: pd.Index,\n    **kwargs\n)\n```\n\n**Parameters:**\n- `index` (pd.Index, required): Multi-level index of datetime and instrument, typically from a feature DataFrame\n- `**kwargs`: Additional arguments passed to internal resampler function\n\n**Returns:**\n- `pd.Series`: Intraday percentage change, aligned to input index\n\n---\n\n### label.maximum_adverse_excursion\n\nCalculate the maximum adverse excursion (lowest price relative to entry) over a given period.\n\n**Signature:**\n```python\nlabel.maximum_adverse_excursion(\n    index: pd.Index,\n    period = 1,\n    trade_at_price = 'close'\n)\n```\n\n**Parameters:**\n- `index` (pd.Index, required): Multi-level index of datetime and instrument\n- `period` (int, optional, default=1): Number of periods to look forward for minimum price\n- `trade_at_price` (str, optional, default='close'): Entry price to compare against ('open', 'high', 'low', 'close')\n\n**Returns:**\n- `pd.Series`: Maximum adverse excursion, aligned to input index\n\n---\n\n### label.maximum_favorable_excursion\n\nCalculate the maximum favorable excursion (highest price relative to entry) over a given period.\n\n**Signature:**\n```python\nlabel.maximum_favorable_excursion(\n    index: pd.Index,\n    period = 1,\n    trade_at_price = 'close'\n)\n```\n\n**Parameters:**\n- `index` (pd.Index, required): Multi-level index of datetime and instrument\n- `period` (int, optional, default=1): Number of periods to look forward for maximum price\n- `trade_at_price` (str, optional, default='close'): Entry price to compare against\n\n**Returns:**\n- `pd.Series`: Maximum favorable excursion, aligned to input index\n\n---\n\n## Complete ML Workflow\n\n### Basic LightGBM Regression Example\n\n```python\nfrom finlab import data\nfrom finlab.ml import feature, label\nfrom finlab.backtest import sim\nfrom finlab.dataframe import FinlabDataFrame\nfrom lightgbm import LGBMRegressor\nimport pandas as pd\n\n# Step 1: Feature Engineering\nfeatures_dict = {\n    'pb': data.get('price_earning_ratio:ËÇ°ÂÉπÊ∑®ÂÄºÊØî'),\n    'pe': data.get('price_earning_ratio:Êú¨ÁõäÊØî'),\n    'rsi': data.indicator('RSI', timeperiod=14),\n    'revenue_growth': data.get('monthly_revenue:ÂéªÂπ¥ÂêåÊúàÂ¢ûÊ∏õ(%)'),\n    'roe': data.get('fundamental_features:ROEÁ®ÖÂæå'),\n}\n\n# Combine features with filtering\nsample_filter = data.get('price:Êàê‰∫§ËÇ°Êï∏') > 200_000\nX = feature.combine(features_dict, resample='M', sample_filter=sample_filter)\n\n# Step 2: Label Generation\ny = label.excess_over_mean(X.index, resample='M', period=1)\n\n# Step 3: Train/Test Split\ntrain_mask = X.index.get_level_values('datetime') < '2020-01-01'\ntest_mask = X.index.get_level_values('datetime') >= '2020-01-01'\n\nX_train = X[train_mask]\ny_train = y[train_mask]\nX_test = X[test_mask]\ny_test = y[test_mask]\n\n# Step 4: Model Training\nmodel = LGBMRegressor(n_estimators=100, learning_rate=0.1, max_depth=5, random_state=42)\nmodel.fit(X_train, y_train)\n\n# Step 5: Prediction and Position Construction\ny_pred = model.predict(X_test)\ndf_y = FinlabDataFrame(y_pred, index=X_test.index).unstack().T\n\n# Step 6: Create Trading Position\nposition = df_y.is_largest(10)  # Select top 10 stocks\n\n# Step 7: Backtest\nreport = sim(position)\nprint(report.get_metrics())\n```\n\n---\n\n### Advanced Feature Selection Example\n\n```python\nfrom finlab import data\nfrom finlab.ml import feature, label\nfrom lightgbm import LGBMRegressor\nfrom sklearn.feature_selection import SelectKBest, f_regression\nimport pandas as pd\n\n# Generate many features\nfeatures_dict = {\n    'pb': data.get('price_earning_ratio:ËÇ°ÂÉπÊ∑®ÂÄºÊØî'),\n    'pe': data.get('price_earning_ratio:Êú¨ÁõäÊØî'),\n    'ps': data.get('price_earning_ratio:ËÇ°ÂÉπÊ∑®ÂÄºÊØî') * data.get('fundamental_features:ÊØèËÇ°ÁáüÊ•≠È°ç'),\n    'rsi_14': data.indicator('RSI', timeperiod=14),\n    'rsi_28': data.indicator('RSI', timeperiod=28),\n    'macd': data.indicator('MACD')[0],  # MACD line\n    'revenue_growth': data.get('monthly_revenue:ÂéªÂπ¥ÂêåÊúàÂ¢ûÊ∏õ(%)'),\n    'revenue_ma3': data.get('monthly_revenue:Áï∂ÊúàÁáüÊî∂').average(3),\n    'roe': data.get('fundamental_features:ROEÁ®ÖÂæå'),\n    'roa': data.get('fundamental_features:ROAÁ∂úÂêàÊêçÁõä'),\n    'gross_margin': data.get('fundamental_features:ÁáüÊ•≠ÊØõÂà©Áéá'),\n    'debt_ratio': data.get('fundamental_features:Ë≤†ÂÇµÊØîÁéá'),\n}\n\n# Combine and clean\nsample_filter = data.get('price:Êàê‰∫§ËÇ°Êï∏') > 200_000\nX = feature.combine(features_dict, resample='M', sample_filter=sample_filter)\ny = label.excess_over_mean(X.index, resample='M', period=1)\n\n# Remove NaN\nmask = ~(X.isna().any(axis=1) | y.isna())\nX = X[mask]\ny = y[mask]\n\n# Feature selection\nselector = SelectKBest(score_func=f_regression, k=6)\nX_selected = selector.fit_transform(X, y)\nselected_features = X.columns[selector.get_support()].tolist()\n\nprint(\"Selected Features:\", selected_features)\n\n# Train model with selected features\nX_selected_df = pd.DataFrame(X_selected, index=X.index, columns=selected_features)\n\n# Split\ntrain_mask = X_selected_df.index.get_level_values('datetime') < '2020-01-01'\ntest_mask = X_selected_df.index.get_level_values('datetime') >= '2020-01-01'\n\nX_train = X_selected_df[train_mask]\ny_train = y[train_mask]\nX_test = X_selected_df[test_mask]\n\n# Train and predict\nmodel = LGBMRegressor(n_estimators=200, learning_rate=0.05, max_depth=6)\nmodel.fit(X_train, y_train)\ny_pred = model.predict(X_test)\n\n# Feature importance\nimportance_df = pd.DataFrame({\n    'feature': selected_features,\n    'importance': model.feature_importances_\n}).sort_values('importance', ascending=False)\n\nprint(\"\\nFeature Importance:\")\nprint(importance_df)\n```\n\n---\n\n### Classification Example\n\n```python\nfrom finlab import data\nfrom finlab.ml import feature, label\nfrom finlab.dataframe import FinlabDataFrame\nfrom finlab.backtest import sim\nfrom lightgbm import LGBMClassifier\nimport pandas as pd\n\n# Feature engineering\nfeatures_dict = {\n    'pb': data.get('price_earning_ratio:ËÇ°ÂÉπÊ∑®ÂÄºÊØî'),\n    'rsi': data.indicator('RSI'),\n    'revenue_growth': data.get('monthly_revenue:ÂéªÂπ¥ÂêåÊúàÂ¢ûÊ∏õ(%)'),\n}\n\nsample_filter = data.get('price:Êàê‰∫§ËÇ°Êï∏') > 200_000\nX = feature.combine(features_dict, resample='M', sample_filter=sample_filter)\n\n# Binary classification label (outperform market or not)\ny_continuous = label.excess_over_mean(X.index, resample='M', period=1)\ny = (y_continuous > 0).astype(int)  # 1 if outperforms, 0 otherwise\n\n# Remove NaN\nmask = ~(X.isna().any(axis=1) | y.isna())\nX = X[mask]\ny = y[mask]\n\n# Split\ntrain_mask = X.index.get_level_values('datetime') < '2020-01-01'\ntest_mask = X.index.get_level_values('datetime') >= '2020-01-01'\n\nX_train = X[train_mask]\ny_train = y[train_mask]\nX_test = X[test_mask]\n\n# Train classifier\nmodel = LGBMClassifier(n_estimators=100, learning_rate=0.1, max_depth=5)\nmodel.fit(X_train, y_train)\n\n# Predict probabilities\ny_pred_proba = model.predict_proba(X_test)[:, 1]  # Probability of class 1\ndf_y = FinlabDataFrame(y_pred_proba, index=X_test.index).unstack().T\n\n# Create position based on probability\nposition = df_y.is_largest(10)  # Top 10 highest probability\n\n# Backtest\nreport = sim(position)\nprint(report.get_metrics())\n```\n\n---\n\n### Time Series Cross-Validation\n\n```python\nfrom finlab import data\nfrom finlab.ml import feature, label\nfrom lightgbm import LGBMRegressor\nfrom sklearn.model_selection import TimeSeriesSplit\nimport pandas as pd\nimport numpy as np\n\n# Prepare features and labels\nfeatures_dict = {\n    'pb': data.get('price_earning_ratio:ËÇ°ÂÉπÊ∑®ÂÄºÊØî'),\n    'rsi': data.indicator('RSI'),\n}\n\nX = feature.combine(features_dict, resample='M')\ny = label.excess_over_mean(X.index, resample='M', period=1)\n\n# Remove NaN\nmask = ~(X.isna().any(axis=1) | y.isna())\nX = X[mask]\ny = y[mask]\n\n# Get unique dates for time series split\ndates = X.index.get_level_values('datetime').unique().sort_values()\ndate_to_idx = {date: idx for idx, date in enumerate(dates)}\nX['date_idx'] = X.index.get_level_values('datetime').map(date_to_idx)\n\n# Time series cross-validation\ntscv = TimeSeriesSplit(n_splits=5)\nscores = []\n\nfor train_idx, val_idx in tscv.split(dates):\n    train_dates = dates[train_idx]\n    val_dates = dates[val_idx]\n\n    X_train = X[X['date_idx'].isin([date_to_idx[d] for d in train_dates])].drop('date_idx', axis=1)\n    y_train = y[X_train.index]\n    X_val = X[X['date_idx'].isin([date_to_idx[d] for d in val_dates])].drop('date_idx', axis=1)\n    y_val = y[X_val.index]\n\n    model = LGBMRegressor(n_estimators=100)\n    model.fit(X_train, y_train)\n    score = model.score(X_val, y_val)\n    scores.append(score)\n    print(f\"Fold R¬≤: {score:.4f}\")\n\nprint(f\"\\nAverage R¬≤: {np.mean(scores):.4f} (+/- {np.std(scores):.4f})\")\n```\n\n---\n\n## Best Practices\n\n### Feature Engineering\n1. **Start with static indicators** - Use `data.indicator()` instead of `feature.ta()` for reproducibility\n2. **Set appropriate resample frequency** - Use 'W', 'ME', 'QE', or `revenue.index` to control data density\n3. **Apply sample filters** - Filter low-volume or special-status stocks using `sample_filter`\n4. **Handle missing data** - Always check and handle NaN values before training\n5. **Normalize features** - Consider scaling features for better model performance\n6. **Ensure proper alignment** - `feature.combine` handles this automatically\n\n### Label Generation\n1. **Match resample frequency** - Ensure label `resample` matches feature `resample`\n2. **Use excess returns** - `excess_over_mean` or `excess_over_median` for better signal\n3. **Consider prediction horizon** - Match `period` to your trading frequency\n4. **Align indices** - Use `features.index` when generating labels\n\n### Model Training\n1. **Time-based splits** - Use `X.index.get_level_values('datetime') > '2020-01-01'` for proper train/test split\n2. **Avoid look-ahead bias** - Never use future information in features\n3. **Cross-validate** - Use time series cross-validation, not random splits\n4. **Tune hyperparameters** - Use validation set for hyperparameter optimization\n5. **Monitor overfitting** - Compare train and test performance regularly\n\n### Position Construction\n1. **Use FinlabDataFrame** - Convert predictions with `FinlabDataFrame(y_pred, index=X_test.index).unstack().T`\n2. **Limit positions** - Use `is_largest(n)` or `is_smallest(n)` for position sizing\n3. **Apply filters** - Combine ML predictions with fundamental or technical filters\n4. **Set stop-loss/take-profit** - Protect against large losses in backtesting\n\n### Backtesting\n1. **Use realistic assumptions** - Include transaction costs and slippage\n2. **Test out-of-sample** - Always backtest on unseen data\n3. **Monitor metrics** - Check Sharpe ratio, max drawdown, and win rate\n4. **Avoid overfitting** - Be wary of perfect backtest results\n\n---\n\n## Related References\n\n- [FinlabDataFrame Reference](dataframe-reference.md) - Enhanced DataFrame methods\n- [Data Reference](data-reference.md) - Available data sources\n- [Factor Examples](factor-examples.md) - Factor-based strategies\n- [Factor Analysis Reference](factor-analysis-reference.md) - Analyze factor performance\n- [Backtesting Reference](backtesting-reference.md) - Backtest ML strategies\n",
  "trading-reference": "# Trading & Order Execution Reference\n\n## Overview\n\nThis reference covers the complete workflow for executing trades from backtest results to live orders. The process involves:\n\n1. **Position Calculation**: Convert backtest results to share quantities\n2. **Broker Connection**: Configure and connect to your broker account\n3. **Order Execution**: Create, update, and manage orders via OrderExecutor\n\n---\n\n## Position Class\n\nThe `Position` class represents target holdings and provides methods for converting backtest results to executable positions.\n\n**Import:**\n```python\nfrom finlab.online.order_executor import Position\n```\n\n### Position.from_report()\n\nConvert a backtest report to tradeable positions.\n\n**Signature:**\n```python\nPosition.from_report(\n    report,\n    fund: float,\n    odd_lot: bool = False\n) -> Position\n```\n\n**Parameters:**\n- `report` (Report, required): Backtest report object from `sim()`\n- `fund` (float, required): Total capital in TWD for position sizing\n- `odd_lot` (bool, default=False): Enable odd lot (Èõ∂ËÇ°) trading for smaller positions\n\n**Returns:**\n- `Position`: List of position dictionaries with stock_id, quantity, and order_condition\n\n**Example:**\n```python\nfrom finlab import backtest\nfrom finlab.online.order_executor import Position\n\nreport = backtest.sim(position, resample=\"M\")\n\n# Standard lot trading\nposition = Position.from_report(report, fund=1000000)\nprint(position)\n# [{'stock_id': '2330', 'quantity': 1, 'order_condition': <OrderCondition.CASH: 1>}]\n\n# Odd lot trading (smaller positions)\nposition = Position.from_report(report, fund=1000000, odd_lot=True)\n```\n\n---\n\n### Custom Position\n\nCreate a position manually without backtest.\n\n**Signature:**\n```python\nPosition(holdings: dict) -> Position\n```\n\n**Example:**\n```python\n# Simple position with share counts\nposition = Position({'2330': 1, '1101': 2})\n\n# Fractional shares (for odd lot)\nposition = Position({'2330': 1, '1101': 1.001})\n```\n\n---\n\n### Position Arithmetic\n\nCombine or modify positions using arithmetic operations.\n\n**Subtraction:**\n```python\n# Remove stocks from position\nnew_position = position - Position({'2330': 1})\n```\n\n**Addition:**\n```python\n# Add stocks to position\nnew_position = position + Position({'1101': 1})\n```\n\n**Multi-strategy combination:**\n```python\n# Combine positions from multiple strategies\nposition1 = Position.from_report(report1, fund=500000)\nposition2 = Position.from_report(report2, fund=500000)\ntotal_position = position1 + position2\n```\n\n---\n\n## Broker Account Setup\n\n### Environment Variables Summary\n\n| Broker | Required Environment Variables |\n|--------|-------------------------------|\n| Esun (ÁéâÂ±±) | `ESUN_CONFIG_PATH`, `ESUN_MARKET_API_KEY`, `ESUN_ACCOUNT_PASSWORD`, `ESUN_CERT_PASSWORD` |\n| Sinopac (Ê∞∏Ë±ê) | `SHIOAJI_API_KEY`, `SHIOAJI_SECRET_KEY`, `SHIOAJI_CERT_PERSON_ID`, `SHIOAJI_CERT_PATH`, `SHIOAJI_CERT_PASSWORD` |\n| Masterlink (ÂÖÉÂØå) | `MASTERLINK_NATIONAL_ID`, `MASTERLINK_ACCOUNT`, `MASTERLINK_ACCOUNT_PASS`, `MASTERLINK_CERT_PATH`, `MASTERLINK_CERT_PASS` |\n| Fubon (ÂØåÈÇ¶) | `FUBON_NATIONAL_ID`, `FUBON_ACCOUNT_PASS`, `FUBON_CERT_PATH` |\n\n---\n\n### Esun (ÁéâÂ±±Ë≠âÂà∏)\n\n**Import:**\n```python\nfrom finlab.online.esun_account import EsunAccount\n```\n\n**Environment Variables:**\n```bash\nexport ESUN_CONFIG_PATH='/path/to/config.ini'\nexport ESUN_MARKET_API_KEY='your_market_api_key'\nexport ESUN_ACCOUNT_PASSWORD='your_password'\nexport ESUN_CERT_PASSWORD='your_cert_password'\n```\n\n**Usage:**\n```python\nimport os\n\nos.environ['ESUN_CONFIG_PATH'] = '/path/to/config.ini'\nos.environ['ESUN_MARKET_API_KEY'] = 'your_market_api_key'\nos.environ['ESUN_ACCOUNT_PASSWORD'] = 'your_password'\nos.environ['ESUN_CERT_PASSWORD'] = 'your_cert_password'\n\nacc = EsunAccount()\n```\n\n**Install SDK:**\n```bash\npip install esun-trade\n```\n\n---\n\n### Sinopac (Ê∞∏Ë±êË≠âÂà∏)\n\n**Import:**\n```python\nfrom finlab.online.sinopac_account import SinopacAccount\n```\n\n**Environment Variables:**\n```bash\nexport SHIOAJI_API_KEY='api_key'\nexport SHIOAJI_SECRET_KEY='secret_key'\nexport SHIOAJI_CERT_PERSON_ID='A123456789'\nexport SHIOAJI_CERT_PATH='/path/to/cert'\nexport SHIOAJI_CERT_PASSWORD='cert_password'\n```\n\n**Usage:**\n```python\nimport os\n\nos.environ['SHIOAJI_API_KEY'] = 'api_key'\nos.environ['SHIOAJI_SECRET_KEY'] = 'secret_key'\nos.environ['SHIOAJI_CERT_PERSON_ID'] = 'A123456789'\nos.environ['SHIOAJI_CERT_PATH'] = '/path/to/cert'\nos.environ['SHIOAJI_CERT_PASSWORD'] = 'cert_password'\n\nacc = SinopacAccount()\n```\n\n**Install SDK:**\n```bash\npip install shioaji\n```\n\n---\n\n### Masterlink (ÂÖÉÂØåË≠âÂà∏)\n\n**Import:**\n```python\nfrom finlab.online.masterlink_account import MasterlinkAccount\n```\n\n**Environment Variables:**\n```bash\nexport MASTERLINK_NATIONAL_ID='A123456789'\nexport MASTERLINK_ACCOUNT='account'\nexport MASTERLINK_ACCOUNT_PASS='password'\nexport MASTERLINK_CERT_PATH='/path/to/cert'\nexport MASTERLINK_CERT_PASS='cert_password'\n```\n\n**Usage:**\n```python\nimport os\n\nos.environ['MASTERLINK_NATIONAL_ID'] = 'A123456789'\nos.environ['MASTERLINK_ACCOUNT'] = 'account'\nos.environ['MASTERLINK_ACCOUNT_PASS'] = 'password'\nos.environ['MASTERLINK_CERT_PATH'] = '/path/to/cert'\nos.environ['MASTERLINK_CERT_PASS'] = 'cert_password'\n\nacc = MasterlinkAccount()\n```\n\n---\n\n### Fubon (ÂØåÈÇ¶Ë≠âÂà∏)\n\n**Import:**\n```python\nfrom finlab.online.fubon_account import FubonAccount\n```\n\n**Environment Variables:**\n```bash\nexport FUBON_NATIONAL_ID='A123456789'\nexport FUBON_ACCOUNT_PASS='password'\nexport FUBON_CERT_PATH='/path/to/cert.pfx'\n```\n\n**Usage:**\n```python\nimport os\n\nos.environ['FUBON_NATIONAL_ID'] = 'A123456789'\nos.environ['FUBON_ACCOUNT_PASS'] = 'password'\nos.environ['FUBON_CERT_PATH'] = '/path/to/cert.pfx'\n\nacc = FubonAccount()\n```\n\n---\n\n## OrderExecutor Class\n\nThe `OrderExecutor` manages order creation, modification, and cancellation.\n\n**Import:**\n```python\nfrom finlab.online.order_executor import OrderExecutor\n```\n\n**Signature:**\n```python\nOrderExecutor(\n    position: Position,\n    account: BrokerAccount\n) -> OrderExecutor\n```\n\n**Parameters:**\n- `position` (Position, required): Target position to execute\n- `account` (BrokerAccount, required): Connected broker account instance\n\n**Example:**\n```python\nfrom finlab.online.order_executor import OrderExecutor, Position\nfrom finlab.online.sinopac_account import SinopacAccount\n\n# Setup\nposition = Position.from_report(report, fund=1000000)\nacc = SinopacAccount()\nexecutor = OrderExecutor(position, account=acc)\n```\n\n---\n\n### OrderExecutor Methods\n\n#### show_alerting_stocks()\n\nDisplay stocks that require pre-deposit (ËôïÁΩÆËÇ°/Ë≠¶Á§∫ËÇ°).\n\n```python\nexecutor.show_alerting_stocks()\n```\n\n---\n\n#### create_orders()\n\nCreate orders based on the target position.\n\n**Signature:**\n```python\ncreate_orders(view_only: bool = False) -> None\n```\n\n**Parameters:**\n- `view_only` (bool, default=False): If True, preview orders without execution\n\n**Example:**\n```python\n# Preview orders first (recommended)\nexecutor.create_orders(view_only=True)\n\n# Execute orders\nexecutor.create_orders()\n```\n\n---\n\n#### update_order_price()\n\nUpdate limit price for pending orders.\n\n```python\nexecutor.update_order_price()\n```\n\n---\n\n#### cancel_orders()\n\nCancel all pending orders.\n\n```python\nexecutor.cancel_orders()\n```\n\n---\n\n## Check Account Position\n\nQuery current holdings from broker.\n\n```python\n# Get current holdings\nprint(acc.get_position())\n```\n\n---\n\n## Related References\n\n- [backtesting-reference.md](backtesting-reference.md): Backtest configuration and report generation\n- [best-practices.md](best-practices.md): Coding patterns and anti-patterns\n"
}


def search_in_docs(query: str) -> list[dict]:
    """Search for a keyword in all documentation."""
    results = []
    query_lower = query.lower()

    for name, content in DOCS.items():
        if query_lower not in content.lower():
            continue

        lines = content.split("\n")
        for i, line in enumerate(lines):
            if query_lower in line.lower():
                start = max(0, i - 2)
                end = min(len(lines), i + 6)
                context = "\n".join(lines[start:end])
                results.append({
                    "file": name,
                    "line": i + 1,
                    "match": context
                })

    return results[:10]


@mcp.tool()
def list_documents() -> str:
    """List all available FinLab documentation files."""
    docs_list = []
    for name, content in sorted(DOCS.items()):
        first_line = ""
        for line in content.split("\n"):
            if line.strip():
                first_line = line.strip("# ").strip()
                break
        docs_list.append(f"- **{name}**: {first_line}")

    return "## Available FinLab Documents\n\n" + "\n".join(docs_list)


@mcp.tool()
def get_document(doc_name: str) -> str:
    """Get the full content of a FinLab documentation file.

    Args:
        doc_name: Name of the document (without .md extension).
                  Available: data-reference, backtesting-reference, dataframe-reference,
                  factor-examples, factor-analysis-reference, trading-reference,
                  best-practices, machine-learning-reference
    """
    if doc_name in DOCS:
        return DOCS[doc_name]

    available = ", ".join(sorted(DOCS.keys()))
    return f"Document '{doc_name}' not found.\n\nAvailable documents: {available}"


@mcp.tool()
def search_finlab_docs(query: str) -> str:
    """Search for a keyword or phrase in all FinLab documentation.

    Args:
        query: The search term to look for (case-insensitive)
    """
    results = search_in_docs(query)

    if not results:
        return f"No results found for '{query}'"

    output = f"## Search Results: {query}\n\n"
    for r in results:
        output += f"### {r['file']} (line {r['line']})\n"
        output += f"```\n{r['match']}\n```\n\n"

    return output


@mcp.tool()
def get_factor_examples(factor_type: str = "all") -> str:
    """Get factor/strategy examples from the documentation.

    Args:
        factor_type: Type of factor to filter by. Options:
                     - "all": All examples
                     - "value": Value investing factors
                     - "momentum": Price momentum strategies
                     - "technical": Technical analysis indicators
                     - "quality": Quality factors
                     - "ml": Machine learning strategies
    """
    if "factor-examples" not in DOCS:
        return "factor-examples not found"

    content = DOCS["factor-examples"]

    if factor_type == "all":
        return content

    factor_type_lower = factor_type.lower()
    sections = content.split("\n## ")

    matching_sections = []
    for section in sections:
        if factor_type_lower in section.lower():
            matching_sections.append("## " + section)

    if not matching_sections:
        return f"No examples found for factor type '{factor_type}'. Try: value, momentum, technical, quality, ml"

    return "\n\n".join(matching_sections)


# Create the Streamable HTTP app for Cloudflare Workers
app = mcp.streamable_http_app()
